<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>Stanford ACM-ICPC Team Notebook</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<CENTER><H1><U>Stanford ACM-ICPC Team Notebook</U></H1></CENTER>
<H1>Table of Contents</H1>
<H2>Combinatorial optimization</H2>

<OL START=1>
<LI><A HREF="#file1">Dinic's</A></LI>
<LI><A HREF="#file2">Min-cost Circulation</A></LI>
<LI><A HREF="#file3">Edmonds Max Matching</A></LI>
<LI><A HREF="#file4">Hungarian Min-cost</A></LI>
<LI><A HREF="#file5">Konig's Theorem (Text)</A></LI>
<LI><A HREF="#file6">Minimum Edge Cover (Text)</A></LI>
</OL>
<H2>Geometry</H2>

<OL START=7>
<LI><A HREF="#file7">Miscellaneous geometry</A></LI>
<LI><A HREF="#file8">3D geometry</A></LI>
<LI><A HREF="#file9">Convex hull</A></LI>
<LI><A HREF="#file10">Min Enclosing Circle</A></LI>
<LI><A HREF="#file11">Pick's Theorem (Text)</A></LI>
<LI><A HREF="#file12">Slow Delaunay triangulation</A></LI>
</OL>
<H2>Numerical algorithms</H2>

<OL START=13>
<LI><A HREF="#file13">Pollard Rho</A></LI>
<LI><A HREF="#file14">Simplex algorithm</A></LI>
<LI><A HREF="#file15">Reduced row echelon form</A></LI>
<LI><A HREF="#file16">Fast Fourier transform</A></LI>
<LI><A HREF="#file17">Number Theoretic transform</A></LI>
<LI><A HREF="#file18">Discrete Logarithm</A></LI>
<LI><A HREF="#file19">Mobius Inversion (Text)</A></LI>
<LI><A HREF="#file20">Burnside Lemma (Text)</A></LI>
<LI><A HREF="#file21">Number Theory (Modular, CRT, Linear Diophantine)</A></LI>
</OL>
<H2>Graph algorithms</H2>

<OL START=22>
<LI><A HREF="#file22">Dynamic Connectivity</A></LI>
<LI><A HREF="#file23">Bridges</A></LI>
<LI><A HREF="#file24">Strongly connected components</A></LI>
</OL>
<H2>String Stuff</H2>

<OL START=25>
<LI><A HREF="#file25">Suffix Automaton</A></LI>
<LI><A HREF="#file26">Suffix array</A></LI>
<LI><A HREF="#file27">Z Algorithm</A></LI>
<LI><A HREF="#file28">KMP</A></LI>
<LI><A HREF="#file29">String Hashing</A></LI>
<LI><A HREF="#file30">Palindrome DSU</A></LI>
<LI><A HREF="#file31">Eertree</A></LI>
</OL>
<H2>Data structures</H2>

<OL START=32>
<LI><A HREF="#file32">BIT Range Queries</A></LI>
<LI><A HREF="#file33">Treaps</A></LI>
<LI><A HREF="#file34">Link-Cut Tree</A></LI>
</OL>
<H2>Miscellaneous</H2>

<OL START=35>
<LI><A HREF="#file35">2-SAT</A></LI>
<LI><A HREF="#file36">Merge Insertion</A></LI>
<LI><A HREF="#file37">DP Optimizations</A></LI>
<LI><A HREF="#file38">Convex Hull Trick (Dynamic)</A></LI>
<LI><A HREF="#file39">Convex Hull Trick (Static)</A></LI>
<LI><A HREF="#file40">BigInt library</A></LI>
<LI><A HREF="#file41">Manachers algorithm</A></LI>
<LI><A HREF="#file42">Dates</A></LI>
<LI><A HREF="#file43">Bitset (Text)</A></LI>
<LI><A HREF="#file44">Template</A></LI>
<LI><A HREF="#file45">Numerical Integration</A></LI>
</OL>
<HR>
<A NAME="file1">
<H1>code/Dinic.cc 1/45</H1>
[<A HREF="#top">top</A>][prev][<A HREF="#file2">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> Dinic {
  <B><FONT COLOR="#228B22">struct</FONT></B> Edge {
    <B><FONT COLOR="#228B22">int</FONT></B> u, v;
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> cap, flow;
    Edge() {}
    Edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> cap): u(u), v(v), cap(cap), flow(0) {}
  }; 
  <B><FONT COLOR="#228B22">int</FONT></B> N;
  vector&lt;Edge&gt; E;
  vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; g;
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; d, pt;

  Dinic(<B><FONT COLOR="#228B22">int</FONT></B> N): N(N), E(0), g(N), d(N), pt(N) {}

  <B><FONT COLOR="#228B22">void</FONT></B> AddEdge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> cap) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (u != v) {
      E.emplace_back(Edge(u, v, cap));
      g[u].emplace_back(E.size() - 1);
      E.emplace_back(Edge(v, u, 0));
      g[v].emplace_back(E.size() - 1);
    }
  }

  <B><FONT COLOR="#228B22">bool</FONT></B> BFS(<B><FONT COLOR="#228B22">int</FONT></B> S, <B><FONT COLOR="#228B22">int</FONT></B> T) {
    queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q({S});
    fill(d.begin(), d.end(), N + 1);
    d[S] = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B>(!q.empty()) {
      <B><FONT COLOR="#228B22">int</FONT></B> u = q.front(); q.pop();
      <B><FONT COLOR="#A020F0">if</FONT></B> (u == T) <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k: g[u]) {
        Edge &amp;e = E[k];
        <B><FONT COLOR="#A020F0">if</FONT></B> (e.flow &lt; e.cap &amp;&amp; d[e.v] &gt; d[e.u] + 1) {
          d[e.v] = d[e.u] + 1;
          q.emplace(e.v);
        }
      }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> d[T] != N + 1;
  }
  <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> DFS(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> T, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> flow = -1) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (u == T || flow == 0) <B><FONT COLOR="#A020F0">return</FONT></B> flow;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> &amp;i = pt[u]; i &lt; g[u].size(); ++i) {
      Edge &amp;e = E[g[u][i]];
      Edge &amp;oe = E[g[u][i]^1];
      <B><FONT COLOR="#A020F0">if</FONT></B> (d[e.v] == d[e.u] + 1) {
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> amt = e.cap - e.flow;
        <B><FONT COLOR="#A020F0">if</FONT></B> (flow != -1 &amp;&amp; amt &gt; flow) amt = flow;
        <B><FONT COLOR="#A020F0">if</FONT></B> (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> pushed = DFS(e.v, T, amt)) {
          e.flow += pushed;
          oe.flow -= pushed;
          <B><FONT COLOR="#A020F0">return</FONT></B> pushed;
        }
      }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
  <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> MaxFlow(<B><FONT COLOR="#228B22">int</FONT></B> S, <B><FONT COLOR="#228B22">int</FONT></B> T) {
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> total = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (BFS(S, T)) {
      fill(pt.begin(), pt.end(), 0);
      <B><FONT COLOR="#A020F0">while</FONT></B> (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> flow = DFS(S, T))
        total += flow;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> total;
  }
};</PRE>
<HR>
<A NAME="file2">
<H1>code/MinCostCirculation.cc 2/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file1">prev</A>][<A HREF="#file3">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Runs in O(&lt;max_flow &gt; * log(V * max_edge_cost)) = O( V^3 * // log(V * C)) Really fast in // practice , 3e4 edges are fine. Operates on integers , // costs are multiplied by N!!
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename flow_t = <B><FONT COLOR="#228B22">int</FONT></B>, typename cost_t = <B><FONT COLOR="#228B22">int</FONT></B>&gt;
<B><FONT COLOR="#228B22">struct</FONT></B> mcSFlow{
  <B><FONT COLOR="#228B22">struct</FONT></B> Edge{
    cost_t c;
    flow_t f;
    <B><FONT COLOR="#228B22">int</FONT></B> to, rev;
    Edge(<B><FONT COLOR="#228B22">int</FONT></B> _to, cost_t _c, flow_t _f, <B><FONT COLOR="#228B22">int</FONT></B> _rev):c(_c), f(_f), to(_to), rev(_rev){}
  };
  <B><FONT COLOR="#228B22">static</FONT></B> constexpr cost_t INFCOST = numeric_limits&lt;cost_t&gt;::max()/2;
  cost_t eps;
  <B><FONT COLOR="#228B22">int</FONT></B> N, S, T;
  vector&lt;vector&lt;Edge&gt; &gt; G;
  vector&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; isq, cur;
  vector&lt;flow_t&gt; ex;
  vector&lt;cost_t&gt; h;
  mcSFlow(<B><FONT COLOR="#228B22">int</FONT></B> _N, <B><FONT COLOR="#228B22">int</FONT></B> _S, <B><FONT COLOR="#228B22">int</FONT></B> _T):eps(0), N(_N), S(_S), T(_T), G(_N){}
  <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, cost_t cost, flow_t cap){
    assert(cap&gt;=0);
    assert(a&gt;=0&amp;&amp;a&lt;N&amp;&amp;b&gt;=0&amp;&amp;b&lt;N);
    <B><FONT COLOR="#A020F0">if</FONT></B>(a==b){assert(cost&gt;=0); <B><FONT COLOR="#A020F0">return</FONT></B>;}
    cost*=N;
    eps = max(eps, abs(cost));
    G[a].emplace_back(b, cost, cap, G[b].size());
    G[b].emplace_back(a, -cost, 0, G[a].size()-1);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> add_flow(Edge&amp; e, flow_t f) {
    Edge &amp;back = G[e.to][e.rev];
    <B><FONT COLOR="#A020F0">if</FONT></B> (!ex[e.to] &amp;&amp; f)
      hs[h[e.to]].push_back(e.to);
    e.f -= f; ex[e.to] += f;
    back.f += f; ex[back.to] -= f;
  }
  vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; hs;
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; co;
  flow_t max_flow() {
    ex.assign(N, 0);
    h.assign(N, 0); hs.resize(2*N);
    co.assign(2*N, 0); cur.assign(N, 0);
    h[S] = N;
    ex[T] = 1;
    co[0] = N-1;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> &amp;e:G[S]) add_flow(e, e.f);
    <B><FONT COLOR="#A020F0">if</FONT></B>(hs[0].size())
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> hi = 0;hi&gt;=0;) {
      <B><FONT COLOR="#228B22">int</FONT></B> u = hs[hi].back();
      hs[hi].pop_back();
      <B><FONT COLOR="#A020F0">while</FONT></B> (ex[u] &gt; 0) { <I><FONT COLOR="#B22222">// discharge u
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (cur[u] == G[u].size()) {
          h[u] = 1e9;
          <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;G[u].size();++i){
            <B><FONT COLOR="#228B22">auto</FONT></B> &amp;e = G[u][i];
            <B><FONT COLOR="#A020F0">if</FONT></B> (e.f &amp;&amp; h[u] &gt; h[e.to]+1){
              h[u] = h[e.to]+1, cur[u] = i;
            }
          }
          <B><FONT COLOR="#A020F0">if</FONT></B> (++co[h[u]], !--co[hi] &amp;&amp; hi &lt; N)
            <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;N;++i)
              <B><FONT COLOR="#A020F0">if</FONT></B> (hi &lt; h[i] &amp;&amp; h[i] &lt; N){
                --co[h[i]];
                h[i] = N + 1;
              }
          hi = h[u];
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (G[u][cur[u]].f &amp;&amp; h[u] == h[G[u][cur[u]].to]+1)
          add_flow(G[u][cur[u]], min(ex[u], G[u][cur[u]].f));
        <B><FONT COLOR="#A020F0">else</FONT></B> ++cur[u];
      }
      <B><FONT COLOR="#A020F0">while</FONT></B> (hi&gt;=0 &amp;&amp; hs[hi].empty()) --hi;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> -ex[S];
  }
  <B><FONT COLOR="#228B22">void</FONT></B> push(Edge &amp;e, flow_t amt){
    <B><FONT COLOR="#A020F0">if</FONT></B>(e.f &lt; amt) amt=e.f;
    e.f-=amt; ex[e.to]+=amt;
    G[e.to][e.rev].f+=amt; ex[G[e.to][e.rev].to]-=amt;
  }
  <B><FONT COLOR="#228B22">void</FONT></B> relabel(<B><FONT COLOR="#228B22">int</FONT></B> vertex){
    cost_t newHeight = -INFCOST;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;G[vertex].size();++i){
      Edge <B><FONT COLOR="#228B22">const</FONT></B>&amp;e = G[vertex][i];
      <B><FONT COLOR="#A020F0">if</FONT></B>(e.f &amp;&amp; newHeight &lt; h[e.to]-e.c){
        newHeight = h[e.to] - e.c;
        cur[vertex] = i;
      }
    }
    h[vertex] = newHeight - eps;
  }
  <B><FONT COLOR="#228B22">static</FONT></B> constexpr <B><FONT COLOR="#228B22">int</FONT></B> scale=2;
  pair&lt;flow_t, cost_t&gt; minCostMaxFlow(){
    cost_t retCost = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;N;++i)
      <B><FONT COLOR="#A020F0">for</FONT></B>(Edge &amp;e:G[i])
        retCost += e.c*(e.f);
    <I><FONT COLOR="#B22222">//find max-flow
</FONT></I>    flow_t retFlow = max_flow();
    h.assign(N, 0); ex.assign(N, 0);
    isq.assign(N, 0); cur.assign(N,0);
    queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q;
    <B><FONT COLOR="#A020F0">for</FONT></B>(;eps;eps&gt;&gt;=scale){
      <I><FONT COLOR="#B22222">//refine
</FONT></I>      fill(cur.begin(), cur.end(), 0);
      <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;N;++i)
        <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> &amp;e:G[i])
          <B><FONT COLOR="#A020F0">if</FONT></B>(h[i] + e.c - h[e.to] &lt; 0 &amp;&amp; e.f) push(e, e.f);
      <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;N;++i){
        <B><FONT COLOR="#A020F0">if</FONT></B>(ex[i]&gt;0){
          q.push(i);
          isq[i]=1;
        }
      }
      <I><FONT COLOR="#B22222">// make flow feasible
</FONT></I>      <B><FONT COLOR="#A020F0">while</FONT></B>(!q.empty()){
        <B><FONT COLOR="#228B22">int</FONT></B> u=q.front();q.pop();
        isq[u]=0;
        <B><FONT COLOR="#A020F0">while</FONT></B>(ex[u]&gt;0){
          <B><FONT COLOR="#A020F0">if</FONT></B>(cur[u] == G[u].size())
            relabel(u);
          <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp;i=cur[u], max_i = G[u].size();i&lt;max_i;++i){
            Edge &amp;e=G[u][i];
            <B><FONT COLOR="#A020F0">if</FONT></B>(h[u] + e.c - h[e.to] &lt; 0){
              push(e, ex[u]);
              <B><FONT COLOR="#A020F0">if</FONT></B>(ex[e.to]&gt;0 &amp;&amp; isq[e.to]==0){
                q.push(e.to);
                isq[e.to]=1;
              }
              <B><FONT COLOR="#A020F0">if</FONT></B>(ex[u]==0) <B><FONT COLOR="#A020F0">break</FONT></B>;
            }
          }
        }
      }
      <B><FONT COLOR="#A020F0">if</FONT></B>(eps&gt;1 &amp;&amp; eps&gt;&gt;scale==0){
        eps = 1&lt;&lt;scale;
      }
    }
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;N;++i){
      <B><FONT COLOR="#A020F0">for</FONT></B>(Edge &amp;e:G[i]){
        retCost -= e.c*(e.f);
      }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(retFlow, retCost/2/N);
  }
  flow_t getFlow(Edge <B><FONT COLOR="#228B22">const</FONT></B> &amp;e){
    <B><FONT COLOR="#A020F0">return</FONT></B> G[e.to][e.rev].f;
  }
};</PRE>
<HR>
<A NAME="file3">
<H1>code/Edmonds.cc 3/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file2">prev</A>][<A HREF="#file4">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXN</FONT> 505
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;g[MAXN];
<B><FONT COLOR="#228B22">int</FONT></B> pa[MAXN],match[MAXN],st[MAXN],S[MAXN],v[MAXN];
<B><FONT COLOR="#228B22">int</FONT></B> t,n;
<B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">lca</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x,<B><FONT COLOR="#228B22">int</FONT></B> y){
  <B><FONT COLOR="#A020F0">for</FONT></B>(++t;;swap(x,y)) <B><FONT COLOR="#A020F0">if</FONT></B>(x){
    <B><FONT COLOR="#A020F0">if</FONT></B>(v[x]==t)<B><FONT COLOR="#A020F0">return</FONT></B> x;
    v[x]=t, x=st[pa[match[x]]];
  }
}
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">qpush</FONT></B>(x) q.push(x),S[x]=0
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">flower</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x,<B><FONT COLOR="#228B22">int</FONT></B> y,<B><FONT COLOR="#228B22">int</FONT></B> l,queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;q){
  <B><FONT COLOR="#A020F0">while</FONT></B>(st[x]!=l){
    pa[x]=y, y=match[x];
    <B><FONT COLOR="#A020F0">if</FONT></B>(S[y]==1) qpush(y);
    st[x]=st[y]=l, x=pa[y];
  }
}
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">bfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x){
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;=n;++i)st[i]=i;
  memset(S+1,-1,<B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B>)*n);
  queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;q;
  qpush(x);
  <B><FONT COLOR="#A020F0">while</FONT></B>(q.size()){
    x=q.front(),q.pop();
    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0;i&lt;g[x].size();++i){
      <B><FONT COLOR="#228B22">int</FONT></B> y=g[x][i];
      <B><FONT COLOR="#A020F0">if</FONT></B>(S[y]==-1){
        pa[y]=x, S[y]=1;
        <B><FONT COLOR="#A020F0">if</FONT></B>(!match[y]){
          <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> lst;x;y=lst,x=pa[y]){
            lst=match[x], match[x]=y, match[y]=x;
          }
          <B><FONT COLOR="#A020F0">return</FONT></B> 1;
        }
        qpush(match[y]);
      } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(!S[y]&amp;&amp;st[y]!=st[x]){
        <B><FONT COLOR="#228B22">int</FONT></B> l=lca(y,x);
        flower(y,x,l,q); flower(x,y,l,q);
      }
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">blossom</FONT></B>(){
  <B><FONT COLOR="#228B22">int</FONT></B> ans=0;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;=n;++i)
    <B><FONT COLOR="#A020F0">if</FONT></B>(!match[i]&amp;&amp;bfs(i))++ans;
  <B><FONT COLOR="#A020F0">return</FONT></B> ans;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
  <B><FONT COLOR="#A020F0">while</FONT></B>(m--){
    g[x].push_back(y);
    g[y].push_back(x);
  }
  printf(<B><FONT COLOR="#BC8F8F">&quot;%d\n&quot;</FONT></B>,blossom());
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;=n;i++)printf(<B><FONT COLOR="#BC8F8F">&quot;%d &quot;</FONT></B>,match[i]);
}</PRE>
<HR>
<A NAME="file4">
<H1>code/MinCostMatching.cc 4/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file3">prev</A>][<A HREF="#file5">next</A>]
<PRE>
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">MinCostMatching</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VVD &amp;cost, VI &amp;Lmate, VI &amp;Rmate) {
  <B><FONT COLOR="#228B22">int</FONT></B> n = <B><FONT COLOR="#228B22">int</FONT></B>(cost.size());
  <I><FONT COLOR="#B22222">// construct dual feasible solution
</FONT></I>  VD u(n);
  VD v(n);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
    u[i] = cost[i][0];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt; n; j++) u[i] = min(u[i], cost[i][j]);
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) {
    v[j] = cost[0][j] - u[0];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; n; i++) v[j] = min(v[j], cost[i][j] - u[i]);
  } 
  <I><FONT COLOR="#B22222">// construct primal solution satisfying complementary slackness
</FONT></I>  Lmate = VI(n, -1);
  Rmate = VI(n, -1);
  <B><FONT COLOR="#228B22">int</FONT></B> mated = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (Rmate[j] != -1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(cost[i][j] - u[i] - v[j]) &lt; 1e-10) {
	Lmate[i] = j;
	Rmate[j] = i;
	mated++;
	<B><FONT COLOR="#A020F0">break</FONT></B>;
      }
    }
  }
  VD dist(n);
  VI dad(n);
  VI seen(n);
  <I><FONT COLOR="#B22222">// repeat until primal solution is feasible
</FONT></I>  <B><FONT COLOR="#A020F0">while</FONT></B> (mated &lt; n) {
    <I><FONT COLOR="#B22222">// find an unmatched left node
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> s = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (Lmate[s] != -1) s++;
    <I><FONT COLOR="#B22222">// initialize Dijkstra
</FONT></I>    fill(dad.begin(), dad.end(), -1);
    fill(seen.begin(), seen.end(), 0);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) 
      dist[k] = cost[s][k] - u[s] - v[k];
    <B><FONT COLOR="#228B22">int</FONT></B> j = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (true) {
      <I><FONT COLOR="#B22222">// find closest
</FONT></I>      j = -1;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (seen[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	<B><FONT COLOR="#A020F0">if</FONT></B> (j == -1 || dist[k] &lt; dist[j]) j = k;
      }
      seen[j] = 1;
      <I><FONT COLOR="#B22222">// termination condition
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (Rmate[j] == -1) <B><FONT COLOR="#A020F0">break</FONT></B>;
      <I><FONT COLOR="#B22222">// relax neighbors
</FONT></I>      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = Rmate[j];
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (seen[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
	<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> new_dist = dist[j] + cost[i][k] - u[i] - v[k];
	<B><FONT COLOR="#A020F0">if</FONT></B> (dist[k] &gt; new_dist) {
	  dist[k] = new_dist;
	  dad[k] = j;
	}
      }
    }
    <I><FONT COLOR="#B22222">// update dual variables
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (k == j || !seen[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = Rmate[k];
      v[k] += dist[k] - dist[j];
      u[i] -= dist[k] - dist[j];
    }
    u[s] += dist[j];
    
    <I><FONT COLOR="#B22222">// augment along path
</FONT></I>    <B><FONT COLOR="#A020F0">while</FONT></B> (dad[j] &gt;= 0) {
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> d = dad[j];
      Rmate[j] = Rmate[d];
      Lmate[Rmate[j]] = j;
      j = d;
    }
    Rmate[j] = s;
    Lmate[s] = j;
    mated++;
  }
  <B><FONT COLOR="#228B22">double</FONT></B> value = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
    value += cost[i][Lmate[i]];
  <B><FONT COLOR="#A020F0">return</FONT></B> value;
}
</PRE>
<HR>
<A NAME="file5">
<H1>code/Konigs.tex 5/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file4">prev</A>][<A HREF="#file6">next</A>]
<PRE>
In any bipartite graph, the number of edges in a maximum matching equals the
number of vertices in a minimum vertex cover. To exhibit the vertex cover:
<B><FONT COLOR="#A020F0">\begin</FONT></B>{enumerate}
<B><FONT COLOR="#A020F0">\itemsep</FONT></B>-0.5em 
<B><FONT COLOR="#A020F0">\item</FONT></B> Find a maximum matching
<B><FONT COLOR="#A020F0">\item</FONT></B> Change each edge <B><FONT COLOR="#A020F0">\textbf</FONT></B>{used} in the matching into a directed edge from
<B><FONT COLOR="#A020F0">\textbf</FONT></B>{right to left}
<B><FONT COLOR="#A020F0">\item</FONT></B> Change each edge <B><FONT COLOR="#A020F0">\textbf</FONT></B>{not used} in the matching into a directed edge
from <B><FONT COLOR="#A020F0">\textbf</FONT></B>{left to right}
<B><FONT COLOR="#A020F0">\item</FONT></B> Compute the set <FONT COLOR="#B8860B">$T$</FONT> of all vertices reachable from unmatched vertices on
the left (including themselves)
<B><FONT COLOR="#A020F0">\item</FONT></B> The vertex cover consists of all vertices on the right that are
<B><FONT COLOR="#A020F0">\textbf</FONT></B>{in} <FONT COLOR="#B8860B">$T$</FONT>, and all vertices on the left that are <B><FONT COLOR="#A020F0">\textbf</FONT></B>{not in} <FONT COLOR="#B8860B">$T$</FONT>
<B><FONT COLOR="#A020F0">\end</FONT></B>{enumerate}</PRE>
<HR>
<A NAME="file6">
<H1>code/minedgecover.tex 6/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file5">prev</A>][<A HREF="#file7">next</A>]
<PRE>
If a minimum edge cover contains <FONT COLOR="#B8860B">$C$</FONT> edges, and a maximum matching contains <FONT COLOR="#B8860B">$M$</FONT>
edges, then <FONT COLOR="#B8860B">$C + M = |V|$</FONT>. To obtain the edge cover, start with a maximum
matching, and then, for every vertex not matched, just select some edge
incident upon it and add it to the edge set. </PRE>
<HR>
<A NAME="file7">
<H1>code/Geometry.cc 7/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file6">prev</A>][<A HREF="#file8">next</A>]
<PRE>
<B><FONT COLOR="#228B22">double</FONT></B> INF = 1e100,EPS = 1e-12;

<B><FONT COLOR="#228B22">struct</FONT></B> PT { 
  <B><FONT COLOR="#228B22">double</FONT></B> x, y; 
  PT() {}
  PT(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y) : x(x), y(y) {}
  PT(<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p) : x(p.x), y(p.y)    {}
  PT <B><FONT COLOR="#A020F0">operator</FONT></B> + (<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p)  <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x+p.x, y+p.y); }
  PT <B><FONT COLOR="#A020F0">operator</FONT></B> - (<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p)  <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x-p.x, y-p.y); }
  PT <B><FONT COLOR="#A020F0">operator</FONT></B> * (<B><FONT COLOR="#228B22">double</FONT></B> c)     <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x*c,   y*c  ); }
  PT <B><FONT COLOR="#A020F0">operator</FONT></B> / (<B><FONT COLOR="#228B22">double</FONT></B> c)     <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x/c,   y/c  ); }
};

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dot</FONT></B>(PT p, PT q)     { <B><FONT COLOR="#A020F0">return</FONT></B> p.x*q.x+p.y*q.y; }
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dist2</FONT></B>(PT p, PT q)   { <B><FONT COLOR="#A020F0">return</FONT></B> dot(p-q,p-q); }
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">cross</FONT></B>(PT p, PT q)   { <B><FONT COLOR="#A020F0">return</FONT></B> p.x*q.y-p.y*q.x; }
ostream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(ostream &amp;os, <B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p) {
  os &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> &lt;&lt; p.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B> &lt;&lt; p.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>; 
}

<I><FONT COLOR="#B22222">// rotate a point CCW or CW around the origin
</FONT></I>PT <B><FONT COLOR="#0000FF">RotateCCW90</FONT></B>(PT p)   { <B><FONT COLOR="#A020F0">return</FONT></B> PT(-p.y,p.x); }
PT <B><FONT COLOR="#0000FF">RotateCW90</FONT></B>(PT p)    { <B><FONT COLOR="#A020F0">return</FONT></B> PT(p.y,-p.x); }
PT <B><FONT COLOR="#0000FF">RotateCCW</FONT></B>(PT p, <B><FONT COLOR="#228B22">double</FONT></B> t) { 
  <B><FONT COLOR="#A020F0">return</FONT></B> PT(p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)); 
}

<I><FONT COLOR="#B22222">// project point c onto line through a and b
</FONT></I><I><FONT COLOR="#B22222">// assuming a != b
</FONT></I>PT <B><FONT COLOR="#0000FF">ProjectPointLine</FONT></B>(PT a, PT b, PT c) {
  <B><FONT COLOR="#A020F0">return</FONT></B> a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);
}

<I><FONT COLOR="#B22222">// project point c onto line segment through a and b
</FONT></I>PT <B><FONT COLOR="#0000FF">ProjectPointSegment</FONT></B>(PT a, PT b, PT c) {
  <B><FONT COLOR="#228B22">double</FONT></B> r = dot(b-a,b-a);
  <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(r) &lt; EPS) <B><FONT COLOR="#A020F0">return</FONT></B> a;
  r = dot(c-a, b-a)/r;
  <B><FONT COLOR="#A020F0">if</FONT></B> (r &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> a;
  <B><FONT COLOR="#A020F0">if</FONT></B> (r &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> b;
  <B><FONT COLOR="#A020F0">return</FONT></B> a + (b-a)*r;
}

<I><FONT COLOR="#B22222">// compute distance from c to segment between a and b
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointSegment</FONT></B>(PT a, PT b, PT c) {
  <B><FONT COLOR="#A020F0">return</FONT></B> sqrt(dist2(c, ProjectPointSegment(a, b, c)));
}

<I><FONT COLOR="#B22222">// compute distance between point (x,y,z) and plane ax+by+cz=d
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointPlane</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y, <B><FONT COLOR="#228B22">double</FONT></B> z,
                          <B><FONT COLOR="#228B22">double</FONT></B> a, <B><FONT COLOR="#228B22">double</FONT></B> b, <B><FONT COLOR="#228B22">double</FONT></B> c, <B><FONT COLOR="#228B22">double</FONT></B> d)
{
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(a*x+b*y+c*z-d)/sqrt(a*a+b*b+c*c);
}

<I><FONT COLOR="#B22222">// determine if lines from a to b and c to d are parallel or collinear
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">LinesParallel</FONT></B>(PT a, PT b, PT c, PT d) { 
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(cross(b-a, c-d)) &lt; EPS; 
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">LinesCollinear</FONT></B>(PT a, PT b, PT c, PT d) { 
  <B><FONT COLOR="#A020F0">return</FONT></B> LinesParallel(a, b, c, d)
      &amp;&amp; fabs(cross(a-b, a-c)) &lt; EPS
      &amp;&amp; fabs(cross(c-d, c-a)) &lt; EPS; 
}

<I><FONT COLOR="#B22222">// determine if line segment from a to b intersects with 
</FONT></I><I><FONT COLOR="#B22222">// line segment from c to d
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">SegmentsIntersect</FONT></B>(PT a, PT b, PT c, PT d) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (LinesCollinear(a, b, c, d)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (dist2(a, c) &lt; EPS || dist2(a, d) &lt; EPS ||
      dist2(b, c) &lt; EPS || dist2(b, d) &lt; EPS) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">if</FONT></B> (dot(c-a, c-b) &gt; 0 &amp;&amp; dot(d-a, d-b) &gt; 0 &amp;&amp; dot(c-b, d-b) &gt; 0)
      <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (cross(d-a, b-a) * cross(c-a, b-a) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
  <B><FONT COLOR="#A020F0">if</FONT></B> (cross(a-c, d-c) * cross(b-c, d-c) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
  <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">// compute intersection of line passing through a and b
</FONT></I><I><FONT COLOR="#B22222">// with line passing through c and d, assuming that unique
</FONT></I><I><FONT COLOR="#B22222">// intersection exists; for segment intersection, check if
</FONT></I><I><FONT COLOR="#B22222">// segments intersect first
</FONT></I>PT <B><FONT COLOR="#0000FF">ComputeLineIntersection</FONT></B>(PT a, PT b, PT c, PT d) {
  b=b-a; d=c-d; c=c-a;
  assert(dot(b, b) &gt; EPS &amp;&amp; dot(d, d) &gt; EPS);
  <B><FONT COLOR="#A020F0">return</FONT></B> a + b*cross(c, d)/cross(b, d);
}

<I><FONT COLOR="#B22222">// compute center of circle given three points
</FONT></I>PT <B><FONT COLOR="#0000FF">ComputeCircleCenter</FONT></B>(PT a, PT b, PT c) {
  b=(a+b)/2;
  c=(a+c)/2;
  <B><FONT COLOR="#A020F0">return</FONT></B> ComputeLineIntersection(b, b+RotateCW90(a-b), c, c+RotateCW90(a-c));
}

<I><FONT COLOR="#B22222">// determine if point is in a possibly non-convex polygon (by William
</FONT></I><I><FONT COLOR="#B22222">// Randolph Franklin); returns 1 for strictly interior points, 0 for
</FONT></I><I><FONT COLOR="#B22222">// strictly exterior points, and 0 or 1 for the remaining points.
</FONT></I><I><FONT COLOR="#B22222">// Note that it is possible to convert this into an *exact* test using
</FONT></I><I><FONT COLOR="#B22222">// integer arithmetic by taking care of the division appropriately
</FONT></I><I><FONT COLOR="#B22222">// (making sure to deal with signs properly) and then by writing exact
</FONT></I><I><FONT COLOR="#B22222">// tests for checking point on polygon boundary
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">PointInPolygon</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p, PT q) {
  <B><FONT COLOR="#228B22">bool</FONT></B> c = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++){
    <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1)%p.size();
    <B><FONT COLOR="#A020F0">if</FONT></B> ((p[i].y &lt;= q.y &amp;&amp; q.y &lt; p[j].y || 
      p[j].y &lt;= q.y &amp;&amp; q.y &lt; p[i].y) &amp;&amp;
      q.x &lt; p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))
      c = !c;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> c;
}

<I><FONT COLOR="#B22222">// determine if point is on the boundary of a polygon
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">PointOnPolygon</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p, PT q) {
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (dist2(ProjectPointSegment(p[i], p[(i+1)%p.size()], q), q) &lt; EPS)
      <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<I><FONT COLOR="#B22222">// compute intersection of line through points a and b with
</FONT></I><I><FONT COLOR="#B22222">// circle centered at c with radius r &gt; 0
</FONT></I>vector&lt;PT&gt; CircleLineIntersection(PT a, PT b, PT c, <B><FONT COLOR="#228B22">double</FONT></B> r) {
  vector&lt;PT&gt; ret;
  b = b-a;
  a = a-c;
  <B><FONT COLOR="#228B22">double</FONT></B> A = dot(b, b);
  <B><FONT COLOR="#228B22">double</FONT></B> B = dot(a, b);
  <B><FONT COLOR="#228B22">double</FONT></B> C = dot(a, a) - r*r;
  <B><FONT COLOR="#228B22">double</FONT></B> D = B*B - A*C;
  <B><FONT COLOR="#A020F0">if</FONT></B> (D &lt; -EPS) <B><FONT COLOR="#A020F0">return</FONT></B> ret;
  ret.push_back(c+a+b*(-B+sqrt(D+EPS))/A);
  <B><FONT COLOR="#A020F0">if</FONT></B> (D &gt; EPS)
    ret.push_back(c+a+b*(-B-sqrt(D))/A);
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// compute intersection of circle centered at a with radius r
</FONT></I><I><FONT COLOR="#B22222">// with circle centered at b with radius R
</FONT></I>vector&lt;PT&gt; CircleCircleIntersection(PT a, PT b, <B><FONT COLOR="#228B22">double</FONT></B> r, <B><FONT COLOR="#228B22">double</FONT></B> R) {
  vector&lt;PT&gt; ret;
  <B><FONT COLOR="#228B22">double</FONT></B> d = sqrt(dist2(a, b));
  <B><FONT COLOR="#A020F0">if</FONT></B> (d &gt; r+R || d+min(r, R) &lt; max(r, R)) <B><FONT COLOR="#A020F0">return</FONT></B> ret;
  <B><FONT COLOR="#228B22">double</FONT></B> x = (d*d-R*R+r*r)/(2*d);
  <B><FONT COLOR="#228B22">double</FONT></B> y = sqrt(r*r-x*x);
  PT v = (b-a)/d;
  ret.push_back(a+v*x + RotateCCW90(v)*y);
  <B><FONT COLOR="#A020F0">if</FONT></B> (y &gt; 0)
    ret.push_back(a+v*x - RotateCCW90(v)*y);
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// This code computes the area or centroid of a (possibly nonconvex)
</FONT></I><I><FONT COLOR="#B22222">// polygon, assuming that the coordinates are listed in a clockwise or
</FONT></I><I><FONT COLOR="#B22222">// counterclockwise fashion.  Note that the centroid is often known as
</FONT></I><I><FONT COLOR="#B22222">// the &quot;center of gravity&quot; or &quot;center of mass&quot;.
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ComputeSignedArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
  <B><FONT COLOR="#228B22">double</FONT></B> area = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
    <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % p.size();
    area += p[i].x*p[j].y - p[j].x*p[i].y;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> area / 2.0;
}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ComputeArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(ComputeSignedArea(p));
}

PT <B><FONT COLOR="#0000FF">ComputeCentroid</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
  PT c(0,0);
  <B><FONT COLOR="#228B22">double</FONT></B> scale = 6.0 * ComputeSignedArea(p);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++){
    <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % p.size();
    c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> c / scale;
}

<I><FONT COLOR="#B22222">// tests whether or not a given polygon (in CW or CCW order) is simple
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">IsSimple</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = i+1; k &lt; p.size(); k++) {
      <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % p.size();
      <B><FONT COLOR="#228B22">int</FONT></B> l = (k+1) % p.size();
      <B><FONT COLOR="#A020F0">if</FONT></B> (i == l || j == k) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      <B><FONT COLOR="#A020F0">if</FONT></B> (SegmentsIntersect(p[i], p[j], p[k], p[l])) 
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> true;
}</PRE>
<HR>
<A NAME="file8">
<H1>code/Geom3D.java 8/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file7">prev</A>][<A HREF="#file9">next</A>]
<PRE>
<B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">class</FONT></B> Geom3D {
  <I><FONT COLOR="#B22222">// distance from point (x, y, z) to plane aX + bY + cZ + d = 0
</FONT></I>  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> ptPlaneDist(<B><FONT COLOR="#A020F0">double</FONT></B> x, <B><FONT COLOR="#A020F0">double</FONT></B> y, <B><FONT COLOR="#A020F0">double</FONT></B> z,
      <B><FONT COLOR="#A020F0">double</FONT></B> a, <B><FONT COLOR="#A020F0">double</FONT></B> b, <B><FONT COLOR="#A020F0">double</FONT></B> c, <B><FONT COLOR="#A020F0">double</FONT></B> d) {
    <B><FONT COLOR="#A020F0">return</FONT></B> Math.abs(a*x + b*y + c*z + d) / Math.sqrt(a*a + b*b + c*c);
  }
  
  <I><FONT COLOR="#B22222">// distance between parallel planes aX + bY + cZ + d1 = 0 and
</FONT></I>  <I><FONT COLOR="#B22222">// aX + bY + cZ + d2 = 0
</FONT></I>  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> planePlaneDist(<B><FONT COLOR="#A020F0">double</FONT></B> a, <B><FONT COLOR="#A020F0">double</FONT></B> b, <B><FONT COLOR="#A020F0">double</FONT></B> c,
      <B><FONT COLOR="#A020F0">double</FONT></B> d1, <B><FONT COLOR="#A020F0">double</FONT></B> d2) {
    <B><FONT COLOR="#A020F0">return</FONT></B> Math.abs(d1 - d2) / Math.sqrt(a*a + b*b + c*c);
  }
  
  <I><FONT COLOR="#B22222">// distance from point (px, py, pz) to line (x1, y1, z1)-(x2, y2, z2)
</FONT></I>  <I><FONT COLOR="#B22222">// (or ray, or segment; in the case of the ray, the endpoint is the
</FONT></I>  <I><FONT COLOR="#B22222">// first point)
</FONT></I>  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> <B><FONT COLOR="#A020F0">int</FONT></B> LINE = 0;
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> <B><FONT COLOR="#A020F0">int</FONT></B> SEGMENT = 1;
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> <B><FONT COLOR="#A020F0">int</FONT></B> RAY = 2;
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> ptLineDistSq(<B><FONT COLOR="#A020F0">double</FONT></B> x1, <B><FONT COLOR="#A020F0">double</FONT></B> y1, <B><FONT COLOR="#A020F0">double</FONT></B> z1,
      <B><FONT COLOR="#A020F0">double</FONT></B> x2, <B><FONT COLOR="#A020F0">double</FONT></B> y2, <B><FONT COLOR="#A020F0">double</FONT></B> z2, <B><FONT COLOR="#A020F0">double</FONT></B> px, <B><FONT COLOR="#A020F0">double</FONT></B> py, <B><FONT COLOR="#A020F0">double</FONT></B> pz,
      <B><FONT COLOR="#A020F0">int</FONT></B> type) {
    <B><FONT COLOR="#A020F0">double</FONT></B> pd2 = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2);
    
    <B><FONT COLOR="#A020F0">double</FONT></B> x, y, z;
    <B><FONT COLOR="#A020F0">if</FONT></B> (pd2 == 0) {
      x = x1;
      y = y1;
      z = z1;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      <B><FONT COLOR="#A020F0">double</FONT></B> u = ((px-x1)*(x2-x1) + (py-y1)*(y2-y1) + (pz-z1)*(z2-z1)) / pd2;
      x = x1 + u * (x2 - x1);
      y = y1 + u * (y2 - y1);
      z = z1 + u * (z2 - z1);
      <B><FONT COLOR="#A020F0">if</FONT></B> (type != LINE &amp;&amp; u &lt; 0) {
        x = x1;
        y = y1;
        z = z1;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (type == SEGMENT &amp;&amp; u &gt; 1.0) {
        x = x2;
        y = y2;
        z = z2;
      }
    }
    
    <B><FONT COLOR="#A020F0">return</FONT></B> (x-px)*(x-px) + (y-py)*(y-py) + (z-pz)*(z-pz);
  }
  
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> ptLineDist(<B><FONT COLOR="#A020F0">double</FONT></B> x1, <B><FONT COLOR="#A020F0">double</FONT></B> y1, <B><FONT COLOR="#A020F0">double</FONT></B> z1,
      <B><FONT COLOR="#A020F0">double</FONT></B> x2, <B><FONT COLOR="#A020F0">double</FONT></B> y2, <B><FONT COLOR="#A020F0">double</FONT></B> z2, <B><FONT COLOR="#A020F0">double</FONT></B> px, <B><FONT COLOR="#A020F0">double</FONT></B> py, <B><FONT COLOR="#A020F0">double</FONT></B> pz,
      <B><FONT COLOR="#A020F0">int</FONT></B> type) {
    <B><FONT COLOR="#A020F0">return</FONT></B> Math.sqrt(ptLineDistSq(x1, y1, z1, x2, y2, z2, px, py, pz, type));
  }
}
</PRE>
<HR>
<A NAME="file9">
<H1>code/ConvexHull.cc 9/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file8">prev</A>][<A HREF="#file10">next</A>]
<PRE>
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt; PT;
<B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#0000FF">cross</FONT></B>(PT o, PT a, PT b){
  PT OA = {a.first-o.first,a.second-o.second};
  PT OB = {b.first-o.first,b.second-o.second};
  <B><FONT COLOR="#A020F0">return</FONT></B> OA.first*OB.second - OA.second*OB.first;
}
<B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dist</FONT></B>(PT a, PT b){
  <B><FONT COLOR="#A020F0">return</FONT></B> sqrt(pow(a.first-b.first,2)+pow(a.second-b.second,2));
}
vector&lt;PT&gt; convexhull(vector&lt;PT&gt; a){
  vector&lt;PT&gt; hull;
  sort(a.begin(),a.end(),[](PT i, PT j){
    <B><FONT COLOR="#A020F0">if</FONT></B>(i.second!=j.second)
      <B><FONT COLOR="#A020F0">return</FONT></B> i.second &lt; j.second;
    <B><FONT COLOR="#A020F0">return</FONT></B> i.first &lt; j.first;
  });
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;a.size();++i){
    <B><FONT COLOR="#A020F0">while</FONT></B>(hull.size()&gt;1 &amp;&amp; cross(hull[hull.size()-2],hull.back(),a[i])&lt;=0)
      hull.pop_back();
    hull.push_back(a[i]);
  }
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=a.size()-1, siz = hull.size();i--;){
    <B><FONT COLOR="#A020F0">while</FONT></B>(hull.size()&gt;siz &amp;&amp; cross(hull[hull.size()-2],hull.back(),a[i])&lt;=0)
      hull.pop_back();
    hull.push_back(a[i]);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> hull;
}</PRE>
<HR>
<A NAME="file10">
<H1>code/MinEnclosingCircle.cc 10/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file9">prev</A>][<A HREF="#file11">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Minimum enclosing circle, Welzl's algorithm
</FONT></I><I><FONT COLOR="#B22222">// Expected linear time.
</FONT></I><I><FONT COLOR="#B22222">// If there are any duplicate points in the input, be sure to remove them first.
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> point {
	<B><FONT COLOR="#228B22">double</FONT></B> x;
	<B><FONT COLOR="#228B22">double</FONT></B> y;
};
<B><FONT COLOR="#228B22">struct</FONT></B> circle {
	<B><FONT COLOR="#228B22">double</FONT></B> x;
	<B><FONT COLOR="#228B22">double</FONT></B> y;
	<B><FONT COLOR="#228B22">double</FONT></B> r;
	circle() {}
	circle(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y, <B><FONT COLOR="#228B22">double</FONT></B> r): x(x), y(y), r(r) {}
};
circle <B><FONT COLOR="#0000FF">b_md</FONT></B>(vector&lt;point&gt; R) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (R.size() == 0) {
		<B><FONT COLOR="#A020F0">return</FONT></B> circle(0, 0, -1);
	} <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (R.size() == 1) {
		<B><FONT COLOR="#A020F0">return</FONT></B> circle(R[0].x, R[0].y, 0);
	} <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (R.size() == 2) {
		<B><FONT COLOR="#A020F0">return</FONT></B> circle((R[0].x+R[1].x)/2.0,
		              (R[0].y+R[1].y)/2.0,
					  hypot(R[0].x-R[1].x, R[0].y-R[1].y)/2.0);
	} <B><FONT COLOR="#A020F0">else</FONT></B> {
		<B><FONT COLOR="#228B22">double</FONT></B> D = (R[0].x - R[2].x)*(R[1].y - R[2].y) - (R[1].x - R[2].x)*(R[0].y - R[2].y);
		<B><FONT COLOR="#228B22">double</FONT></B> p0 = (((R[0].x - R[2].x)*(R[0].x + R[2].x) + (R[0].y - R[2].y)*(R[0].y + R[2].y)) / 2 * (R[1].y - R[2].y) - ((R[1].x - R[2].x)*(R[1].x + R[2].x) + (R[1].y - R[2].y)*(R[1].y + R[2].y)) / 2 * (R[0].y - R[2].y))/D;
		<B><FONT COLOR="#228B22">double</FONT></B> p1 = (((R[1].x - R[2].x)*(R[1].x + R[2].x) + (R[1].y - R[2].y)*(R[1].y + R[2].y)) / 2 * (R[0].x - R[2].x) - ((R[0].x - R[2].x)*(R[0].x + R[2].x) + (R[0].y - R[2].y)*(R[0].y + R[2].y)) / 2 * (R[1].x - R[2].x))/D;
		<B><FONT COLOR="#A020F0">return</FONT></B> circle(p0, p1, hypot(R[0].x - p0, R[0].y - p1));
	}
}
circle <B><FONT COLOR="#0000FF">b_minidisk</FONT></B>(vector&lt;point&gt;&amp; P, <B><FONT COLOR="#228B22">int</FONT></B> i, vector&lt;point&gt; R) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (i == P.size() || R.size() == 3) {
		<B><FONT COLOR="#A020F0">return</FONT></B> b_md(R);
	} <B><FONT COLOR="#A020F0">else</FONT></B> {
		circle D = b_minidisk(P, i+1, R);
		<B><FONT COLOR="#A020F0">if</FONT></B> (hypot(P[i].x-D.x, P[i].y-D.y) &gt; D.r) {
			R.push_back(P[i]);
			D = b_minidisk(P, i+1, R);
		}
		<B><FONT COLOR="#A020F0">return</FONT></B> D;
	}
}

<I><FONT COLOR="#B22222">// Call this function.
</FONT></I>circle <B><FONT COLOR="#0000FF">minidisk</FONT></B>(vector&lt;point&gt; P) {
	random_shuffle(P.begin(), P.end());
	<B><FONT COLOR="#A020F0">return</FONT></B> b_minidisk(P, 0, vector&lt;point&gt;());
}</PRE>
<HR>
<A NAME="file11">
<H1>code/Pick.tex 11/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file10">prev</A>][<A HREF="#file12">next</A>]
<PRE>
For a polygon with all vertices on lattice points, <FONT COLOR="#B8860B">$A = i + b/2 - 1$</FONT>, where <FONT COLOR="#B8860B">$A$</FONT>kon
is the area, <FONT COLOR="#B8860B">$i$</FONT> is the number of lattice points strictly within the polygon,
and <FONT COLOR="#B8860B">$b$</FONT> is the number of lattice points on the boundary of the polygon. (Note,
there is no generalization to higher dimensions)</PRE>
<HR>
<A NAME="file12">
<H1>code/Delaunay.cc 12/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file11">prev</A>][<A HREF="#file13">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Slow but simple Delaunay triangulation. Does not
</FONT></I><I><FONT COLOR="#B22222">// handle degenerate cases (from O'Rourke)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^4)
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    x[] = x-coordinates
</FONT></I><I><FONT COLOR="#B22222">//           y[] = y-coordinates
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   triples = a vector containing m triples of
</FONT></I><I><FONT COLOR="#B22222">//           indices corresponding to triangle vertices
</FONT></I>
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;

<B><FONT COLOR="#228B22">struct</FONT></B> triple {
  <B><FONT COLOR="#228B22">int</FONT></B> i, j, k;
  triple() {}
  triple(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j, <B><FONT COLOR="#228B22">int</FONT></B> k) : i(i), j(j), k(k) {}
};
vector&lt;triple&gt; delaunayTriangulation(vector&lt;T&gt;&amp; x, vector&lt;T&gt;&amp; y) {
  <B><FONT COLOR="#228B22">int</FONT></B> n = x.size();
  vector&lt;T&gt; z(n);
  vector&lt;triple&gt; ret;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
    z[i] = x[i] * x[i] + y[i] * y[i];
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n-2; i++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i+1; j &lt; n; j++) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = i+1; k &lt; n; k++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (j == k) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#228B22">double</FONT></B> xn = (y[j]-y[i])*(z[k]-z[i]) - (y[k]-y[i])*(z[j]-z[i]);
        <B><FONT COLOR="#228B22">double</FONT></B> yn = (x[k]-x[i])*(z[j]-z[i]) - (x[j]-x[i])*(z[k]-z[i]);
        <B><FONT COLOR="#228B22">double</FONT></B> zn = (x[j]-x[i])*(y[k]-y[i]) - (x[k]-x[i])*(y[j]-y[i]);
        <B><FONT COLOR="#228B22">bool</FONT></B> flag = zn &lt; 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> m = 0; flag &amp;&amp; m &lt; n; m++)
          flag = flag &amp;&amp; ((x[m]-x[i])*xn + (y[m]-y[i])*yn + (z[m]-z[i])*zn &lt;= 0);
        <B><FONT COLOR="#A020F0">if</FONT></B> (flag) ret.push_back(triple(i, j, k));
      }
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
  T xs[]={0, 0, 1, 0.9};
  T ys[]={0, 1, 0, 0.9};
  vector&lt;T&gt; x(&amp;xs[0], &amp;xs[4]), y(&amp;ys[0], &amp;ys[4]);
  vector&lt;triple&gt; tri = delaunayTriangulation(x, y);
  <I><FONT COLOR="#B22222">//expected: 0 1 3
</FONT></I>  <I><FONT COLOR="#B22222">//          0 3 2
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; tri.size(); i++)
    printf(<B><FONT COLOR="#BC8F8F">&quot;%d %d %d\n&quot;</FONT></B>, tri[i].i, tri[i].j, tri[i].k);
}</PRE>
<HR>
<A NAME="file13">
<H1>code/pollard_rho.cc 13/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file12">prev</A>][<A HREF="#file14">next</A>]
<PRE>
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> llui;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> lli;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> float64;

llui <B><FONT COLOR="#0000FF">mul_mod</FONT></B>(llui a, llui b, llui m){
  llui y = (llui)((float64)a*(float64)b/m+(float64)1/2);
  y = y * m;
  llui x = a * b;
  llui r = x - y;
  <B><FONT COLOR="#A020F0">if</FONT></B> ( (lli)r &lt; 0 ){
    r = r + m; y = y - 1;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> r;
}
llui C,a,b;
llui <B><FONT COLOR="#0000FF">gcd</FONT></B>(){
  llui c;
  <B><FONT COLOR="#A020F0">if</FONT></B>(a&gt;b){
    c = a; a = b; b = c;
  }
  <B><FONT COLOR="#A020F0">while</FONT></B>(1){
    <B><FONT COLOR="#A020F0">if</FONT></B>(a == 1LL) <B><FONT COLOR="#A020F0">return</FONT></B> 1LL;
    <B><FONT COLOR="#A020F0">if</FONT></B>(a == 0 || a == b) <B><FONT COLOR="#A020F0">return</FONT></B> b;
    c = a; a = b%a;
    b = c;
  }
}
llui <B><FONT COLOR="#0000FF">f</FONT></B>(llui a, llui b){
  llui tmp;
  tmp = mul_mod(a,a,b);
  tmp+=C; tmp%=b;
  <B><FONT COLOR="#A020F0">return</FONT></B> tmp;
}
llui <B><FONT COLOR="#0000FF">pollard</FONT></B>(llui n){
  <B><FONT COLOR="#A020F0">if</FONT></B>(!(n&amp;1)) <B><FONT COLOR="#A020F0">return</FONT></B> 2;
  C=0;
  llui iteracoes = 0;
  <B><FONT COLOR="#A020F0">while</FONT></B>(iteracoes &lt;= 1000){
    llui x,y,d;
    x = y = 2; d = 1;
    <B><FONT COLOR="#A020F0">while</FONT></B>(d == 1){
       x = f(x,n);
       y = f(f(y,n),n);
       llui m = (x&gt;y)?(x-y):(y-x);
       a = m; b = n; d = gcd();
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(d != n)
       <B><FONT COLOR="#A020F0">return</FONT></B> d;
    iteracoes++; C = rand();
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}
llui <B><FONT COLOR="#0000FF">pot</FONT></B>(llui a, llui b, llui c){
  <B><FONT COLOR="#A020F0">if</FONT></B>(b == 0) <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  <B><FONT COLOR="#A020F0">if</FONT></B>(b == 1) <B><FONT COLOR="#A020F0">return</FONT></B> a%c;
  llui resp = pot(a,b&gt;&gt;1,c);
  resp = mul_mod(resp,resp,c);
  <B><FONT COLOR="#A020F0">if</FONT></B>(b&amp;1)
    resp = mul_mod(resp,a,c);
  <B><FONT COLOR="#A020F0">return</FONT></B> resp;
}
<I><FONT COLOR="#B22222">// Rabin-Miller primality testing algorithm
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">isPrime</FONT></B>(llui n){
  llui d = n-1;
  llui s = 0;
  <B><FONT COLOR="#A020F0">if</FONT></B>(n &lt;=3 || n == 5) <B><FONT COLOR="#A020F0">return</FONT></B> true;
  <B><FONT COLOR="#A020F0">if</FONT></B>(!(n&amp;1)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
  <B><FONT COLOR="#A020F0">while</FONT></B>(!(d&amp;1)){ s++; d&gt;&gt;=1; }
  <B><FONT COLOR="#A020F0">for</FONT></B>(llui i = 0;i&lt;32;i++){
    llui a = rand();
    a &lt;&lt;=32;
    a+=rand();
    a%=(n-3); a+=2;
    llui x = pot(a,d,n);
    <B><FONT COLOR="#A020F0">if</FONT></B>(x == 1 || x == n-1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    <B><FONT COLOR="#A020F0">for</FONT></B>(llui j = 1;j&lt;= s-1;j++){
      x = mul_mod(x,x,n);
      <B><FONT COLOR="#A020F0">if</FONT></B>(x == 1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
      <B><FONT COLOR="#A020F0">if</FONT></B>(x == n-1)<B><FONT COLOR="#A020F0">break</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(x != n-1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
map&lt;llui,<B><FONT COLOR="#228B22">int</FONT></B>&gt; factors;
<I><FONT COLOR="#B22222">// Precondition: factors is an empty map, n is a positive integer
</FONT></I><I><FONT COLOR="#B22222">// Postcondition: factors[p] is the exponent of p in prime factorization of n
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">fact</FONT></B>(llui n){
  <B><FONT COLOR="#A020F0">if</FONT></B>(!isPrime(n)){
    llui fac = pollard(n);
    fact(n/fac); fact(fac);
  }<B><FONT COLOR="#A020F0">else</FONT></B>{
    map&lt;llui,<B><FONT COLOR="#228B22">int</FONT></B>&gt;::iterator it;
    it = factors.find(n);
    <B><FONT COLOR="#A020F0">if</FONT></B>(it != factors.end()){
      (*it).second++;
    }<B><FONT COLOR="#A020F0">else</FONT></B>{
      factors[n] = 1;
    }
  }
}
</PRE>
<HR>
<A NAME="file14">
<H1>code/Simplex.cc 14/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file13">prev</A>][<A HREF="#file15">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Two-phase simplex algorithm for solving linear programs of the form
</FONT></I><I><FONT COLOR="#B22222">//     maximize     c^T x
</FONT></I><I><FONT COLOR="#B22222">//     subject to   Ax &lt;= b ; x &gt;= 0
</FONT></I><I><FONT COLOR="#B22222">// INPUT: A -- an m x n matrix
</FONT></I><I><FONT COLOR="#B22222">//        b -- an m-dimensional vector
</FONT></I><I><FONT COLOR="#B22222">//        c -- an n-dimensional vector
</FONT></I><I><FONT COLOR="#B22222">//        x -- a vector where the optimal solution will be stored
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT: value of the optimal solution (infinity if
</FONT></I><I><FONT COLOR="#B22222">//         unbounded above, nan if infeasible)
</FONT></I><I><FONT COLOR="#B22222">// To use this code, create an LPSolver object with 
</FONT></I><I><FONT COLOR="#B22222">// A, b, and c as arguments. Then, call Solve(x).
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> DOUBLE;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;DOUBLE&gt; VD;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VD&gt; VVD;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">const</FONT></B> DOUBLE EPS = 1e-9;
<B><FONT COLOR="#228B22">struct</FONT></B> LPSolver {
  <B><FONT COLOR="#228B22">int</FONT></B> m, n;
  VI B, N;
  VVD D;
  LPSolver(<B><FONT COLOR="#228B22">const</FONT></B> VVD &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> VD &amp;b, <B><FONT COLOR="#228B22">const</FONT></B> VD &amp;c) :
    m(b.size()), n(c.size()), N(n + 1), B(m), D(m + 2, VD(n + 2)) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) D[i][j] = A[i][j];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) { B[i] = n + i; D[i][n] = -1; D[i][n + 1] = b[i]; }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) { N[j] = j; D[m][j] = -c[j]; }
    N[n] = -1; D[m + 1][n] = 1;
  }
  <B><FONT COLOR="#228B22">void</FONT></B> Pivot(<B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">int</FONT></B> s) {
    <B><FONT COLOR="#228B22">double</FONT></B> inv = 1.0 / D[r][s];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m + 2; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (i != r)
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n + 2; j++) <B><FONT COLOR="#A020F0">if</FONT></B> (j != s)
        D[i][j] -= D[r][j] * D[i][s] * inv;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n + 2; j++) <B><FONT COLOR="#A020F0">if</FONT></B> (j != s) D[r][j] *= inv;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m + 2; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (i != r) D[i][s] *= -inv;
    D[r][s] = inv;
    swap(B[r], N[s]);
  }
  <B><FONT COLOR="#228B22">bool</FONT></B> Simplex(<B><FONT COLOR="#228B22">int</FONT></B> phase) {
    <B><FONT COLOR="#228B22">int</FONT></B> x = phase == 1 ? m + 1 : m;
    <B><FONT COLOR="#A020F0">while</FONT></B> (true) {
      <B><FONT COLOR="#228B22">int</FONT></B> s = -1;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt;= n; j++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (phase == 2 &amp;&amp; N[j] == -1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (s == -1 || D[x][j] &lt; D[x][s] || D[x][j] == D[x][s] &amp;&amp; N[j] &lt; N[s]) s = j;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (D[x][s] &gt; -EPS) <B><FONT COLOR="#A020F0">return</FONT></B> true;
      <B><FONT COLOR="#228B22">int</FONT></B> r = -1;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (D[i][s] &lt; EPS) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (r == -1 || D[i][n + 1] / D[i][s] &lt; D[r][n + 1] / D[r][s] ||
          (D[i][n + 1] / D[i][s]) == (D[r][n + 1] / D[r][s]) &amp;&amp; B[i] &lt; B[r]) r = i;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (r == -1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
      Pivot(r, s);
    }
  }
  DOUBLE Solve(VD &amp;x) {
    <B><FONT COLOR="#228B22">int</FONT></B> r = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; m; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (D[i][n + 1] &lt; D[r][n + 1]) r = i;
    <B><FONT COLOR="#A020F0">if</FONT></B> (D[r][n + 1] &lt; -EPS) {
      Pivot(r, n);
      <B><FONT COLOR="#A020F0">if</FONT></B> (!Simplex(1) || D[m + 1][n + 1] &lt; -EPS) <B><FONT COLOR="#A020F0">return</FONT></B> -numeric_limits&lt;DOUBLE&gt;::infinity();
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (B[i] == -1) {
        <B><FONT COLOR="#228B22">int</FONT></B> s = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt;= n; j++)
          <B><FONT COLOR="#A020F0">if</FONT></B> (s == -1 || D[i][j] &lt; D[i][s] || D[i][j] == D[i][s] &amp;&amp; N[j] &lt; N[s]) s = j;
        Pivot(i, s);
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!Simplex(2)) <B><FONT COLOR="#A020F0">return</FONT></B> numeric_limits&lt;DOUBLE&gt;::infinity();
    x = VD(n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (B[i] &lt; n) x[B[i]] = D[i][n + 1];
    <B><FONT COLOR="#A020F0">return</FONT></B> D[m][n + 1];
  }
};
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = 4, n = 3;
  DOUBLE _A[m][n] = {
    { 6, -1, 0 },
    { -1, -5, 0 },
    { 1, 5, 1 },
    { -1, -5, -1 }
  };
  DOUBLE _b[m] = { 10, -4, 5, -5 }, _c[n] = { 1, -1, 0 };
  VVD A(m);
  VD b(_b, _b + m), c(_c, _c + n);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) A[i] = VD(_A[i], _A[i] + n);
  LPSolver solver(A, b, c);
  VD x;
  DOUBLE value = solver.Solve(x);
  cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;VALUE: &quot;</FONT></B> &lt;&lt; value &lt;&lt; endl; <I><FONT COLOR="#B22222">// VALUE: 1.29032
</FONT></I>  cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;SOLUTION:&quot;</FONT></B>; <I><FONT COLOR="#B22222">// SOLUTION: 1.74194 0.451613 1
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B> (size_t i = 0; i &lt; x.size(); i++) cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; x[i];
}
</PRE>
<HR>
<A NAME="file15">
<H1>code/ReducedRowEchelonForm.cc 15/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file14">prev</A>][<A HREF="#file16">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Reduced row echelon form via Gauss-Jordan elimination 
</FONT></I><I><FONT COLOR="#B22222">// with partial pivoting. This can be used for
</FONT></I><I><FONT COLOR="#B22222">// computing the rank of a matrix.
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^3)
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    a[][] = an nxm matrix
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   rref[][] = an nxm matrix (stored in a[][])
</FONT></I><I><FONT COLOR="#B22222">//           returns rank of a[][]
</FONT></I>
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> EPSILON = 1e-10;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">rref</FONT></B>(VVT &amp;a) {
  <B><FONT COLOR="#228B22">int</FONT></B> n = a.size(), m = a[0].size(), r = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> c = 0; c &lt; m &amp;&amp; r &lt; n; c++) {
    <B><FONT COLOR="#228B22">int</FONT></B> j = r;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = r + 1; i &lt; n; i++)
      <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[i][c]) &gt; fabs(a[j][c])) j = i;
    <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[j][c]) &lt; EPSILON) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    swap(a[j], a[r]);

    T s = 1.0 / a[r][c];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++) a[r][j] *= s;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (i != r) {
      T t = a[i][c];
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++) a[i][j] -= t * a[r][j];
    }
    r++;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> r;
}
</PRE>
<HR>
<A NAME="file16">
<H1>code/FFT.cc 16/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file15">prev</A>][<A HREF="#file17">next</A>]
<PRE>
<B><FONT COLOR="#228B22">template</FONT></B>&lt;typename fpt&gt;
<B><FONT COLOR="#228B22">struct</FONT></B> fft_wrap {
  using cpx_t = <B><FONT COLOR="#228B22">complex</FONT></B>&lt;fpt&gt;;
  <B><FONT COLOR="#228B22">const</FONT></B> fpt two_pi = 4 * acosl(0);

  vector&lt;cpx_t&gt; roots; <I><FONT COLOR="#B22222">//stores the N-th roots of unity.
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> N;

  fft_wrap(<B><FONT COLOR="#228B22">int</FONT></B> N) : roots(N), N(N) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; ++i) {
      roots[i] = EXP(two_pi * i / fpt(N));
    }
  }

  cpx_t EXP(fpt theta) {
    <B><FONT COLOR="#A020F0">return</FONT></B> {cos(theta), sin(theta)};
  }

  <B><FONT COLOR="#228B22">void</FONT></B> fft(cpx_t *in, cpx_t *out, <B><FONT COLOR="#228B22">int</FONT></B> size, <B><FONT COLOR="#228B22">int</FONT></B> dir){
    bit_reverse(in, out, size);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> s = 0; (1 &lt;&lt; s) &lt; size; ++s) {
      <B><FONT COLOR="#228B22">int</FONT></B> s_ = s + 1;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; size; k += (1 &lt;&lt; s_)) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; (1 &lt;&lt; s); ++j) {
          <B><FONT COLOR="#228B22">int</FONT></B> id = (N + dir * (N &gt;&gt; s_) * j) &amp; (N - 1);
          cpx_t w = roots[id];
          cpx_t t = w * out[k + j + (1 &lt;&lt; s)];
          cpx_t u = out[k + j];
          out[k + j] = u + t;
          out[k + j + (1 &lt;&lt; s)] = u - t;
        }
      }
    }
  }

  <B><FONT COLOR="#228B22">void</FONT></B> bit_reverse(cpx_t *in, cpx_t *out, <B><FONT COLOR="#228B22">int</FONT></B> size){
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; size; ++i) {
      <B><FONT COLOR="#228B22">int</FONT></B> rev = 0, i_copy = i;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; (1 &lt;&lt; j) &lt; size; ++j) {
        rev = (rev &lt;&lt; 1) + (i_copy &amp; 1);
        i_copy &gt;&gt;= 1;
      }
      out[rev] = in[i];
    }
  }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
  <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">complex</FONT></B>&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; cpx_t;
  fft_wrap&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; fft_wrapper(2048);

  vector&lt;cpx_t&gt; in = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0}, out(8);

  fft_wrapper.fft(&amp;in[0], &amp;out[0], 8, 1);
  fft_wrapper.fft(&amp;out[0], &amp;in[0], 8, -1);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 8; ++i) {
    cout &lt;&lt; in[i].real() &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B> &lt;&lt; in[i].imag() &lt;&lt; endl;
  }
}</PRE>
<HR>
<A NAME="file17">
<H1>code/NTT.cpp 17/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file16">prev</A>][<A HREF="#file18">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// gen should be 5^((p - 1) / fft_wrapper_size)
</FONT></I>
<B><FONT COLOR="#228B22">template</FONT></B>&lt;<B><FONT COLOR="#228B22">int</FONT></B> P&gt;
<B><FONT COLOR="#228B22">struct</FONT></B> field_t { ... };

<B><FONT COLOR="#228B22">template</FONT></B>&lt;typename fpt, <B><FONT COLOR="#228B22">int</FONT></B> gen&gt;
<B><FONT COLOR="#228B22">struct</FONT></B> fft_wrap {
  vector&lt;fpt&gt; roots; <I><FONT COLOR="#B22222">//stores the N-th roots of unity.
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> N;
  fft_wrap(<B><FONT COLOR="#228B22">int</FONT></B> _N) : roots(_N), N(_N) {
    roots[0] = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; N; ++i) {
      roots[i] = roots[i - 1] * gen;
      <B><FONT COLOR="#A020F0">if</FONT></B> (i != N - 1) {
        assert(roots[i].v != 1);
      }
    }
  }
  <B><FONT COLOR="#228B22">void</FONT></B> fft(fpt *in, fpt *out, <B><FONT COLOR="#228B22">int</FONT></B> size, <B><FONT COLOR="#228B22">int</FONT></B> dir) {
    bit_reverse(in, out, size);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> s = 0; (1 &lt;&lt; s) &lt; size; ++s) {
      <B><FONT COLOR="#228B22">int</FONT></B> s_ = s + 1;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; size; k += (1 &lt;&lt; s_)) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; (1 &lt;&lt; s); ++j) {
          <B><FONT COLOR="#228B22">int</FONT></B> id = (N + dir * (N &gt;&gt; s_) * j) &amp; (N - 1);
          fpt w = roots[id];
          fpt t = w * out[k + j + (1 &lt;&lt; s)];
          fpt u = out[k + j];
          out[k + j] = u + t;
          out[k + j + (1 &lt;&lt; s)] = u - t;
        }
      }
    }
  }
  <B><FONT COLOR="#228B22">void</FONT></B> bit_reverse(fpt *in, fpt *out, <B><FONT COLOR="#228B22">int</FONT></B> size) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; size; ++i) {
      <B><FONT COLOR="#228B22">int</FONT></B> rev = 0, i_copy = i;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; (1 &lt;&lt; j) &lt; size; ++j) {
        rev = (rev &lt;&lt; 1) + (i_copy &amp; 1);
        i_copy &gt;&gt;= 1;
      }
      out[rev] = in[i];
    }
  }
};

using fpt = field_t&lt;mod&gt;;
fft_wrap&lt;fpt, gen&gt; fft_wrapper(1 &lt;&lt; 18);

vector&lt;fpt&gt; polymul(vector&lt;fpt&gt; P1, vector&lt;fpt&gt; P2) {
  <B><FONT COLOR="#228B22">int</FONT></B> fsize = P1.size() + P2.size() - 1;
  <B><FONT COLOR="#228B22">int</FONT></B> N = max(P1.size(), P2.size());
  <B><FONT COLOR="#A020F0">while</FONT></B>(N &amp; (N - 1)) {
    ++N;
  }
  N *= 2;
  P1.resize(N); P2.resize(N);
  vector&lt;fpt&gt; temp(N);
  fft_wrapper.fft(&amp;P1[0], &amp;temp[0], N, 1);
  fft_wrapper.fft(&amp;P2[0], &amp;P1[0], N, 1);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; ++i) {
    P1[i] *= temp[i];
  }
  fft_wrapper.fft(&amp;P1[0], &amp;temp[0], N, -1);
  field_t&lt;mod&gt; inv(N);
  inv = inv.modexp(mod - 2);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; ++i) {
    temp[i] *= inv;
  }
  temp.resize(fsize);
  <B><FONT COLOR="#A020F0">return</FONT></B> temp;
}</PRE>
<HR>
<A NAME="file18">
<H1>code/discrete_log.cc 18/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file17">prev</A>][<A HREF="#file19">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Calculates x such that g^x % md == h
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">baby_giant</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> g, <B><FONT COLOR="#228B22">int</FONT></B> h, <B><FONT COLOR="#228B22">int</FONT></B> md){
  unordered_map&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt; mp;
  <B><FONT COLOR="#228B22">int</FONT></B> sq = ceil(sqrtl(md));
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0,now=1;i&lt;sq;++i)
    mp[now] = i, now = (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>) now*g % md;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0,jmp=power(g,md-1-sq);i&lt;sq;++i){
    <B><FONT COLOR="#A020F0">if</FONT></B>(mp.find(h)!=mp.end()) <B><FONT COLOR="#A020F0">return</FONT></B> i*sq+mp[h];
    h = (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>) h*jmp % md;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> -1;
}</PRE>
<HR>
<A NAME="file19">
<H1>code/Mobius.tex 19/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file18">prev</A>][<A HREF="#file20">next</A>]
<PRE>
$<B><FONT COLOR="#A020F0">\mu</FONT></B>(n) = <B><FONT COLOR="#A020F0">\begin</FONT></B>{cases}
0 &amp; <B><FONT COLOR="#A020F0">\text</FONT></B>{<FONT COLOR="#B8860B">$n$</FONT> not squarefree} <B><FONT COLOR="#A020F0">\\</FONT></B>
1 &amp; <B><FONT COLOR="#A020F0">\text</FONT></B>{<FONT COLOR="#B8860B">$n$</FONT> squarefree w/ even no. of prime factors} <B><FONT COLOR="#A020F0">\\</FONT></B>
1 &amp; <B><FONT COLOR="#A020F0">\text</FONT></B>{<FONT COLOR="#B8860B">$n$</FONT> squarefree w/ odd no. of prime factors} <B><FONT COLOR="#A020F0">\\</FONT></B>
<B><FONT COLOR="#A020F0">\end</FONT></B>{cases}$<B><FONT COLOR="#A020F0">\\</FONT></B>
Note that <FONT COLOR="#B8860B">$\mu(a) \mu(b) = \mu(ab)$</FONT> for <FONT COLOR="#B8860B">$a, b$</FONT> relatively prime<B><FONT COLOR="#A020F0">\\</FONT></B>
Also <FONT COLOR="#B8860B">$\sum_{d \mid n} \mu(d) = \begin{cases} 1 &amp; \text{if $</FONT>n = 1$} <B><FONT COLOR="#A020F0">\\</FONT></B>
0 &amp; <B><FONT COLOR="#A020F0">\text</FONT></B>{otherwise} <B><FONT COLOR="#A020F0">\end</FONT></B>{cases}$

<B><FONT COLOR="#A020F0">\textbf</FONT></B>{M<B><FONT COLOR="#A020F0">\&quot;</FONT></B>obius Inversion}
If <FONT COLOR="#B8860B">$g(n) = \sum_{d|n} f(d)$</FONT> for all <FONT COLOR="#B8860B">$n \ge 1$</FONT>, then
<FONT COLOR="#B8860B">$f(n) = \sum_{d|n} \mu(d)g(n/d)$</FONT> for all <FONT COLOR="#B8860B">$n \ge 1$</FONT>.<B><FONT COLOR="#A020F0">\\</FONT></B>
</PRE>
<HR>
<A NAME="file20">
<H1>code/Burnside.tex 20/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file19">prev</A>][<A HREF="#file21">next</A>]
<PRE>
The number of orbits of a set <FONT COLOR="#B8860B">$X$</FONT> under the group action <FONT COLOR="#B8860B">$G$</FONT> equals the average
number of elements of <FONT COLOR="#B8860B">$X$</FONT> fixed by the elements of <FONT COLOR="#B8860B">$G$</FONT>.

Here's an example. Consider a square of <FONT COLOR="#B8860B">$2n$</FONT> times <FONT COLOR="#B8860B">$2n$</FONT> cells. How many ways
are there to color it into <FONT COLOR="#B8860B">$X$</FONT> colors, up to rotations and/or reflections?
Here, the group has only 8 elements (rotations by 0, 90, 180 and 270 degrees,
reflections over two diagonals, over a vertical line and over a horizontal
line). Every coloring stays itself after rotating by 0 degrees, so that
rotation has <FONT COLOR="#B8860B">$X^{4n^2}$</FONT> fixed points. Rotation by 180 degrees and reflections
over a horizonal/vertical line split all cells in pairs that must be of the
same color for a coloring to be unaffected by such rotation/reflection, thus
there exist <FONT COLOR="#B8860B">$X^{2n^2}$</FONT> such colorings for each of them. Rotations by 90 and 270
degrees split cells in groups of four, thus yielding <FONT COLOR="#B8860B">$X^{n^2}$</FONT> fixed colorings.
Reflections over diagonals split cells into <FONT COLOR="#B8860B">$2n$</FONT> groups of 1 (the diagonal
itself) and <FONT COLOR="#B8860B">$2n^2-n$</FONT> groups of 2 (all remaining cells), thus yielding
<FONT COLOR="#B8860B">$X^{2n^2-n+2n}=X^{2n^2+n}$</FONT> unaffected colorings.  So, the answer is
<FONT COLOR="#B8860B">$(X^{4n^2}+3X^{2n^2}+2X^{n^2}+2X^{2n^2+n})/8$</FONT>.
</PRE>
<HR>
<A NAME="file21">
<H1>code/Euclid.cc 21/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file20">prev</A>][<A HREF="#file22">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// All algorithms described here work on nonnegative integers.
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">mod</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
  <B><FONT COLOR="#A020F0">return</FONT></B> ((a%b) + b) % b;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">lcm</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
  <B><FONT COLOR="#A020F0">return</FONT></B> a / __gcd(a, b)*b;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">powermod</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> m){
  <B><FONT COLOR="#A020F0">return</FONT></B> b?powermod(a*a%m,b/2,m)*(b%2?a:1)%m:1;
}
<I><FONT COLOR="#B22222">// returns g = gcd(a, b); finds x, y such that d = ax + by
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">extended_euclid</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> &amp;x, <B><FONT COLOR="#228B22">int</FONT></B> &amp;y) {
  <B><FONT COLOR="#228B22">int</FONT></B> xx = y = 0;
  <B><FONT COLOR="#228B22">int</FONT></B> yy = x = 1;
  <B><FONT COLOR="#A020F0">while</FONT></B> (b) {
    <B><FONT COLOR="#228B22">int</FONT></B> q = a / b;
    <B><FONT COLOR="#228B22">int</FONT></B> t = b; b = a%b; a = t;
    t = xx; xx = x - q*xx; x = t;
    t = yy; yy = y - q*yy; y = t;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> a;
}
<I><FONT COLOR="#B22222">// finds all solutions to ax = b (mod n)
</FONT></I>VI <B><FONT COLOR="#0000FF">modular_linear_equation_solver</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> n) {
  <B><FONT COLOR="#228B22">int</FONT></B> x, y;
  VI ret;
  <B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(a, n, x, y);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!(b%g)) {
    x = mod(x*(b / g), n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; g; i++)
      ret.push_back(mod(x + i*(n / g), n));
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<I><FONT COLOR="#B22222">// computes b such that ab = 1 (mod n), returns -1 on failure
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">mod_inverse</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> n) {
  <B><FONT COLOR="#228B22">int</FONT></B> x, y;
  <B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(a, n, x, y);
  <B><FONT COLOR="#A020F0">if</FONT></B> (g &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> -1;
  <B><FONT COLOR="#A020F0">return</FONT></B> mod(x, n);
}
<I><FONT COLOR="#B22222">// Chinese remainder theorem (special case): find z such
</FONT></I><I><FONT COLOR="#B22222">// that z % m1 = r1, z % m2 = r2.  
</FONT></I><I><FONT COLOR="#B22222">// Here, z is unique modulo M = lcm(m1, m2). 
</FONT></I><I><FONT COLOR="#B22222">// Return (z, M).  On failure, M = -1.
</FONT></I>PII <B><FONT COLOR="#0000FF">chinese_remainder_theorem</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> m1, <B><FONT COLOR="#228B22">int</FONT></B> r1, <B><FONT COLOR="#228B22">int</FONT></B> m2, <B><FONT COLOR="#228B22">int</FONT></B> r2) {
  <B><FONT COLOR="#228B22">int</FONT></B> s, t;
  <B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(m1, m2, s, t);
  <B><FONT COLOR="#A020F0">if</FONT></B> (r1%g != r2%g) <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(0, -1);
  <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(mod(s*r2*m1 + t*r1*m2, m1*m2) / g, m1*m2 / g);
}
<I><FONT COLOR="#B22222">// Find z such that z % m[i] = r[i] for all i. 
</FONT></I><I><FONT COLOR="#B22222">// The solution is unique modulo M = lcm_i (m[i]).
</FONT></I><I><FONT COLOR="#B22222">// Return (z, M). On failure, M = -1.
</FONT></I><I><FONT COLOR="#B22222">// We don't require a[i]'s to be relatively prime.
</FONT></I>PII <B><FONT COLOR="#0000FF">chinese_remainder_theorem</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VI &amp;m,<B><FONT COLOR="#228B22">const</FONT></B> VI &amp;r){
  PII ret = make_pair(r[0], m[0]);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; m.size(); i++) {
    ret = chinese_remainder_theorem(ret.second, ret.first, m[i], r[i]);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ret.second == -1) <B><FONT COLOR="#A020F0">break</FONT></B>;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
<I><FONT COLOR="#B22222">// computes x and y such that ax + by = c
</FONT></I><I><FONT COLOR="#B22222">// returns whether the solution exists
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">linear_diophantine</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> c, <B><FONT COLOR="#228B22">int</FONT></B> &amp;x, <B><FONT COLOR="#228B22">int</FONT></B> &amp;y) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (!a &amp;&amp; !b) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (c) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    x = 0; y = 0;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!a) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (c % b) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    x = 0; y = c / b;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!b) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (c % a) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    x = c / a; y = 0;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
  }
  <B><FONT COLOR="#228B22">int</FONT></B> g = __gcd(a, b);
  <B><FONT COLOR="#A020F0">if</FONT></B> (c % g) <B><FONT COLOR="#A020F0">return</FONT></B> false;
  x = c / g * mod_inverse(a / g, b / g);
  y = (c - a*x) / b;
  <B><FONT COLOR="#A020F0">return</FONT></B> true;
}</PRE>
<HR>
<A NAME="file22">
<H1>code/dynconn.cpp 22/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file21">prev</A>][<A HREF="#file23">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> UnionFind {
  <B><FONT COLOR="#228B22">int</FONT></B> n,comp;
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; uf,si,c;
  UnionFind(<B><FONT COLOR="#228B22">int</FONT></B> n=0):n(n),comp(n),uf(n),si(n,1){
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i) 
      uf[i]=i;
  }
  <B><FONT COLOR="#228B22">int</FONT></B> find(<B><FONT COLOR="#228B22">int</FONT></B> x){<B><FONT COLOR="#A020F0">return</FONT></B> x==uf[x]?x:find(uf[x]);}
  <B><FONT COLOR="#228B22">bool</FONT></B> join(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y){
    <B><FONT COLOR="#A020F0">if</FONT></B>((x=find(x))==(y=find(y))) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">if</FONT></B>(si[x]&lt;si[y]) swap(x,y);
    si[x]+=si[y];uf[y]=x;comp--;
    c.push_back(y);
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
  }
  <B><FONT COLOR="#228B22">int</FONT></B> snap(){<B><FONT COLOR="#A020F0">return</FONT></B> c.size();}
  <B><FONT COLOR="#228B22">void</FONT></B> rollback(<B><FONT COLOR="#228B22">int</FONT></B> snap){
    <B><FONT COLOR="#A020F0">while</FONT></B>(c.size()&gt;snap){
      <B><FONT COLOR="#228B22">int</FONT></B> x=c.back(); c.pop_back();
      si[uf[x]]-=si[x];uf[x]=x;comp++;
    }
  }
};
<B><FONT COLOR="#228B22">enum</FONT></B> {ADD,DEL,QUERY};
<B><FONT COLOR="#228B22">struct</FONT></B> Query {<B><FONT COLOR="#228B22">int</FONT></B> type,x,y;};
<B><FONT COLOR="#228B22">struct</FONT></B> DynCon {
  vector&lt;Query&gt; q;
  UnionFind dsu;
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; mt;
  map&lt;pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt;,<B><FONT COLOR="#228B22">int</FONT></B>&gt; last;
  DynCon(<B><FONT COLOR="#228B22">int</FONT></B> n):dsu(n){}
  <B><FONT COLOR="#228B22">void</FONT></B> add(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y){
    <B><FONT COLOR="#A020F0">if</FONT></B>(x&gt;y) swap(x,y);
    q.push_back((Query){ADD,x,y}),mt.push_back(-1);
    last[make_pair(x,y)]=q.size()-1;
  }
  <B><FONT COLOR="#228B22">void</FONT></B> remove(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y){
    <B><FONT COLOR="#A020F0">if</FONT></B>(x&gt;y)swap(x,y);
    q.push_back((Query){DEL,x,y});
    <B><FONT COLOR="#228B22">int</FONT></B> pr=last[make_pair(x,y)];
    mt[pr]=q.size()-1;
    mt.push_back(pr);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> query(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y){
    q.push_back((Query){QUERY,x,y});
    mt.push_back(-1);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> process(){ <I><FONT COLOR="#B22222">// answers all queries in order
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!q.size()) <B><FONT COLOR="#A020F0">return</FONT></B>;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;q.size();++i) 
      <B><FONT COLOR="#A020F0">if</FONT></B>(q[i].type==ADD&amp;&amp;mt[i]&lt;0)
        mt[i]=q.size();
    go(0,q.size());
  }
  <B><FONT COLOR="#228B22">void</FONT></B> go(<B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r){
    <B><FONT COLOR="#A020F0">if</FONT></B>(l+1==r){
      <B><FONT COLOR="#A020F0">if</FONT></B>(q[l].type==QUERY) <I><FONT COLOR="#B22222">// answer query using DSU
</FONT></I>        puts(dsu.find(q[l].x)==dsu.find(q[l].y)? <B><FONT COLOR="#BC8F8F">&quot;YES&quot;</FONT></B>:<B><FONT COLOR="#BC8F8F">&quot;NO&quot;</FONT></B>);
      <B><FONT COLOR="#A020F0">return</FONT></B>;
    }
    <B><FONT COLOR="#228B22">int</FONT></B> s=dsu.snap(),m=(l+r)/2;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=r-1;i&gt;=m;--i)
      <B><FONT COLOR="#A020F0">if</FONT></B>(mt[i]&gt;=0&amp;&amp;mt[i]&lt;l)
        dsu.join(q[i].x,q[i].y);
    go(l,m);
    dsu.rollback(s);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=m-1;i&gt;=l;--i)<B><FONT COLOR="#A020F0">if</FONT></B>(mt[i]&gt;=r)dsu.join(q[i].x,q[i].y);
    go(m,r);
    dsu.rollback(s);
  }
};</PRE>
<HR>
<A NAME="file23">
<H1>code/bridges.cpp 23/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file22">prev</A>][<A HREF="#file24">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Finds bridges and cut vertices
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Receives:
</FONT></I><I><FONT COLOR="#B22222">// N: number of vertices
</FONT></I><I><FONT COLOR="#B22222">// l: adjacency list
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Gives:
</FONT></I><I><FONT COLOR="#B22222">// vis, seen, par (used to find cut vertices)
</FONT></I><I><FONT COLOR="#B22222">// ap - 1 if it is a cut vertex, 0 otherwise
</FONT></I><I><FONT COLOR="#B22222">// brid - vector of pairs containing the bridges
</FONT></I>
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;

<B><FONT COLOR="#228B22">int</FONT></B> N;
vector &lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; l[MAX];
vector &lt;PII&gt; brid;
<B><FONT COLOR="#228B22">int</FONT></B> vis[MAX], seen[MAX], par[MAX], ap[MAX];
<B><FONT COLOR="#228B22">int</FONT></B> cnt, root;

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">dfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x){
  <B><FONT COLOR="#A020F0">if</FONT></B>(vis[x] != -1)
    <B><FONT COLOR="#A020F0">return</FONT></B>;
  vis[x] = seen[x] = cnt++;
  
  <B><FONT COLOR="#228B22">int</FONT></B> adj = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>)l[x].size(); i++){
    <B><FONT COLOR="#228B22">int</FONT></B> v = l[x][i];
    <B><FONT COLOR="#A020F0">if</FONT></B>(par[x] == v)
      <B><FONT COLOR="#A020F0">continue</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B>(vis[v] == -1){
      adj++;
      par[v] = x;
      dfs(v);
      seen[x] = min(seen[x], seen[v]);
      <B><FONT COLOR="#A020F0">if</FONT></B>(seen[v] &gt;= vis[x] &amp;&amp; x != root)
        ap[x] = 1;
      <B><FONT COLOR="#A020F0">if</FONT></B>(seen[v] == vis[v])
        brid.push_back(make_pair(v, x));
    }
    <B><FONT COLOR="#A020F0">else</FONT></B>{
      seen[x] = min(seen[x], vis[v]);
      seen[v] = min(seen[x], seen[v]);
    }
  }
  <B><FONT COLOR="#A020F0">if</FONT></B>(x == root) ap[x] = (adj&gt;1);
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">bridges</FONT></B>(){
  brid.clear();
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++){
    vis[i] = seen[i] = par[i] = -1;
    ap[i] = 0;
  }
  cnt = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B>(vis[i] == -1){
      root = i;
      dfs(i);
    }
}
</PRE>
<HR>
<A NAME="file24">
<H1>code/SCC.cc 24/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file23">prev</A>][<A HREF="#file25">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> SCC {
  <B><FONT COLOR="#228B22">int</FONT></B> V, group_cnt;
  vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; adj, radj;
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; group_num, vis;
  stack&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; stk;
  <I><FONT COLOR="#B22222">// V = number of vertices
</FONT></I>  SCC(<B><FONT COLOR="#228B22">int</FONT></B> V): V(V), group_cnt(0), group_num(V), vis(V), adj(V), radj(V) {}

  <I><FONT COLOR="#B22222">// Call this to add an edge (0-based)
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> v1, <B><FONT COLOR="#228B22">int</FONT></B> v2) {
    adj[v1].push_back(v2);
    radj[v2].push_back(v1);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> fill_forward(<B><FONT COLOR="#228B22">int</FONT></B> x) {
    vis[x] = true;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; adj[x].size(); i++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (!vis[adj[x][i]]) {
        fill_forward(adj[x][i]);
      }
    }
    stk.push(x);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> fill_backward(<B><FONT COLOR="#228B22">int</FONT></B> x) {
    vis[x] = false;
    group_num[x] = group_cnt;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; radj[x].size(); i++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (vis[radj[x][i]]) {
        fill_backward(radj[x][i]);
      }
    }
  }
  <I><FONT COLOR="#B22222">// Returns number of strongly connected components.
</FONT></I>  <I><FONT COLOR="#B22222">// After this is called, group_num contains component assignments (0-based)
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> get_scc() {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; V; i++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (!vis[i]) fill_forward(i);
    }
    group_cnt = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (!stk.empty()) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (vis[stk.top()]) {
        fill_backward(stk.top());
        group_cnt++;
      }
      stk.pop();
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> group_cnt;
  }
};
</PRE>
<HR>
<A NAME="file25">
<H1>code/SAM.cc 25/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file24">prev</A>][<A HREF="#file26">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> SuffixAutomaton {
  vector&lt;map&lt;<B><FONT COLOR="#228B22">char</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; edges; <I><FONT COLOR="#B22222">// edges[i]: the labeled edges from node i
</FONT></I>  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; link;   <I><FONT COLOR="#B22222">// link[i]  : the parent of i
</FONT></I>  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; length; <I><FONT COLOR="#B22222">// length[i]: length of longest string in ith class
</FONT></I>  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; cnt;    <I><FONT COLOR="#B22222">// No. of times substring occurs
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> last;  <I><FONT COLOR="#B22222">// index of equivalence class of whole string
</FONT></I>  SuffixAutomaton(string <B><FONT COLOR="#228B22">const</FONT></B>&amp; s) {
    <I><FONT COLOR="#B22222">// add the initial node
</FONT></I>    edges.push_back(map&lt;<B><FONT COLOR="#228B22">char</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt;());
    link.push_back(-1);
    length.push_back(0);
    cnt.push_back(0);
    last = 0;

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;s.size();i++) {
      <I><FONT COLOR="#B22222">// construct r
</FONT></I>      edges.push_back(map&lt;<B><FONT COLOR="#228B22">char</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt;());
      length.push_back(i+1);
      link.push_back(0);
      cnt.push_back(1);
      <B><FONT COLOR="#228B22">int</FONT></B> r = edges.size() - 1;
      <I><FONT COLOR="#B22222">// add edges to r and find p with link to q
</FONT></I>      <B><FONT COLOR="#228B22">int</FONT></B> p = last;
      <B><FONT COLOR="#A020F0">while</FONT></B>(p &gt;= 0 &amp;&amp; !edges[p].count(s[i])){
        edges[p][s[i]] = r;
        p = link[p];
      }
      <B><FONT COLOR="#A020F0">if</FONT></B>(p != -1) {
        <B><FONT COLOR="#228B22">int</FONT></B> q = edges[p][s[i]];
        <B><FONT COLOR="#A020F0">if</FONT></B>(length[p] + 1 == length[q]) {
          <I><FONT COLOR="#B22222">// we do not have to split q, just set the correct suffix link
</FONT></I>          link[r] = q;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          <I><FONT COLOR="#B22222">// we have to split, add q'
</FONT></I>          edges.push_back(edges[q]); <I><FONT COLOR="#B22222">// copy edges of q
</FONT></I>          length.push_back(length[p] + 1);
          link.push_back(link[q]); <I><FONT COLOR="#B22222">// copy parent of q
</FONT></I>          cnt.push_back(0);
          <B><FONT COLOR="#228B22">int</FONT></B> qq = edges.size()-1;
          <I><FONT COLOR="#B22222">// add qq as the new parent of q and r
</FONT></I>          link[q] = link[r] = qq; cnt[r] = 1;
          <I><FONT COLOR="#B22222">// move short classes pointing to q to point to q'
</FONT></I>          <B><FONT COLOR="#A020F0">while</FONT></B>(p &gt;= 0 &amp;&amp; edges[p][s[i]] == q) {
            edges[p][s[i]] = qq;
            p = link[p];
          }
        }
      }
      last = r;
    }
    
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; ind(length.size());
    iota(ind.begin(), ind.end(), 0);
    sort(ind.begin(), ind.end(), [&amp;](<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j){
      <B><FONT COLOR="#A020F0">return</FONT></B> length[i] &gt; length[j];
    });
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> i:ind) <B><FONT COLOR="#A020F0">if</FONT></B>(link[i] &gt;= 0)
      cnt[link[i]] += cnt[i];
  }
};</PRE>
<HR>
<A NAME="file26">
<H1>code/SuffixArray.cc 26/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file25">prev</A>][<A HREF="#file27">next</A>]
<PRE>
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; suffix_array(<B><FONT COLOR="#228B22">const</FONT></B> string &amp;s){
  <B><FONT COLOR="#228B22">int</FONT></B> n = s.size();
  <B><FONT COLOR="#228B22">int</FONT></B> *mem = (<B><FONT COLOR="#228B22">int</FONT></B>*)malloc(n*24);
  <B><FONT COLOR="#228B22">int</FONT></B> *blk=mem, *sa=mem+n, *cnt=mem+2*n, *b=mem+3*n, *tmp=mem+4*n, *fast=mem+5*n;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i) sa[i] = n-i-1;
  stable_sort(sa,sa+n,[&amp;](<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j){<B><FONT COLOR="#A020F0">return</FONT></B> s[i]&lt;s[j];});
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i) blk[i]=s[i];
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> len=1;len&lt;n;len*=2){
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i) b[i]=blk[i],tmp[i]=sa[i]-len,cnt[i]=i;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i)
      blk[sa[i]]=i&amp;&amp;b[sa[i-1]]==b[sa[i]]&amp;&amp;sa[i-1]+len&lt;n&amp;&amp;b[sa[i-1]+len/2]==b[sa[i]+len/2]?blk[sa[i-1]]:i;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i) fast[i]=(tmp[i]&gt;=0?blk[tmp[i]]:-1);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i) <B><FONT COLOR="#A020F0">if</FONT></B>(~fast[i]) sa[cnt[fast[i]]++]=tmp[i];
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(sa,sa+n);
}
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; kasai(string &amp;s, vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;sa){
  <B><FONT COLOR="#228B22">int</FONT></B> n = s.size();
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; lcp(n),inv(n);
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i) inv[sa[i]] = i;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0,k=0;i&lt;n;++i){
    <B><FONT COLOR="#A020F0">if</FONT></B>(k&lt;0) k = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B>(inv[i]==n-1){ k=0; <B><FONT COLOR="#A020F0">continue</FONT></B>; }
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j=sa[inv[i]+1];max(i,j)+k&lt;n&amp;&amp;s[i+k]==s[j+k];++k);
    lcp[inv[i]] = k--;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> lcp;
}</PRE>
<HR>
<A NAME="file27">
<H1>code/Zalgo.cc 27/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file26">prev</A>][<A HREF="#file28">next</A>]
<PRE>
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; compute_Z(string s) {
  <B><FONT COLOR="#228B22">int</FONT></B> n = s.length();
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; z(n, 0);
  z[0] = n;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1, l = 0, r = 0; i &lt; n; ++i) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (r &gt;= i) {
      z[i] = min(z[i - l], r - i + 1);
    }
    <B><FONT COLOR="#A020F0">while</FONT></B> (i+z[i] &lt; n and s[i+z[i]] == s[z[i]]) {
      ++z[i];
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (i + z[i] - 1 &gt; r) {
      r = i + z[i] - 1;
      l = i;
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> z;
}</PRE>
<HR>
<A NAME="file28">
<H1>code/KMP.cc 28/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file27">prev</A>][<A HREF="#file29">next</A>]
<PRE>
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; find_prefix(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;P){
  <B><FONT COLOR="#228B22">int</FONT></B> M = P.size();
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; pi(M);
  <I><FONT COLOR="#B22222">/* pi[i] &lt;- largest prefix P[0..pi[i]] which is a suffix of P[0..i]
   * (but not equal to it) */</FONT></I>
  pi[0] = -1;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1, k = -1; i &lt; M; ++i) {
    <B><FONT COLOR="#A020F0">while</FONT></B>(k &gt; -1 &amp;&amp; P[k + 1] != P[i])
      k = pi[k];
    <B><FONT COLOR="#A020F0">if</FONT></B> (P[k + 1] == P[i]) ++k;
    pi[i] = k;
  } 
  <B><FONT COLOR="#A020F0">return</FONT></B> pi;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">kmp_matcher</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;T, <B><FONT COLOR="#228B22">const</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;P){
  <B><FONT COLOR="#228B22">int</FONT></B> M = P.size(), N = T.size();
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; pi = find_prefix(P);
  <B><FONT COLOR="#228B22">int</FONT></B> q = -1, matches = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; ++i) {
    <B><FONT COLOR="#A020F0">while</FONT></B>(q &gt; -1 &amp;&amp; P[q + 1] != T[i])
      q = pi[q];
    <B><FONT COLOR="#A020F0">if</FONT></B> (P[q + 1] == T[i]) ++q;
    <B><FONT COLOR="#A020F0">if</FONT></B> (q == M - 1)
      ++matches, q = pi[q];
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> matches;
}</PRE>
<HR>
<A NAME="file29">
<H1>code/string_hash.cc 29/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file28">prev</A>][<A HREF="#file30">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> hasher{
  <B><FONT COLOR="#228B22">int</FONT></B> hashes[MAXN+5];
  <B><FONT COLOR="#228B22">int</FONT></B> *pow, *inv;
  <B><FONT COLOR="#228B22">int</FONT></B> mod;
  <B><FONT COLOR="#228B22">int</FONT></B> n;
  <B><FONT COLOR="#228B22">void</FONT></B> init(string &amp;str, <B><FONT COLOR="#228B22">int</FONT></B> *p, <B><FONT COLOR="#228B22">int</FONT></B> *i, <B><FONT COLOR="#228B22">int</FONT></B> m){
    pow = p;
    inv = i;
    mod = m; 
    n = str.size();
    <B><FONT COLOR="#228B22">int</FONT></B> last = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++){
      <B><FONT COLOR="#228B22">int</FONT></B> c = str[i] - <B><FONT COLOR="#BC8F8F">'a'</FONT></B> + 1;
      last = (last + 1ll*c*pow[i]) % mod;
      hashes[i] = last;
    }
  }
  <B><FONT COLOR="#228B22">int</FONT></B> getHash(<B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r){
    <B><FONT COLOR="#A020F0">if</FONT></B> (r &gt;= n || l &lt; 0)
      <B><FONT COLOR="#A020F0">return</FONT></B> -1;
    <B><FONT COLOR="#228B22">int</FONT></B> curr = hashes[r] - (l-1 &gt;= 0 ? hashes[l-1] : 0);
    curr = ((curr % mod) + mod) % mod;
    curr = (1ll*curr*inv[l]) % mod;
    <B><FONT COLOR="#A020F0">return</FONT></B> curr;
  }
} A, B, C;</PRE>
<HR>
<A NAME="file30">
<H1>code/palindrome_dsu.cc 30/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file29">prev</A>][<A HREF="#file31">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// given an unknown string s and Q ranges that
</FONT></I><I><FONT COLOR="#B22222">// are know to be palindromes, this computes the characters
</FONT></I><I><FONT COLOR="#B22222">// that have to be equal in O(Q + n log n)
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> Palindrome{
  Palindrome(){}
  Palindrome(<B><FONT COLOR="#228B22">int</FONT></B> n_):n(n_), m(3+__lg(n)), qs(m), p(2*n){
    iota(p.begin(), p.end(), 0);
  }
  <B><FONT COLOR="#228B22">int</FONT></B> f(<B><FONT COLOR="#228B22">int</FONT></B> i){
    <B><FONT COLOR="#A020F0">return</FONT></B> p[i] == i ? i : p[i] = f(p[i]);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> u(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b){
    assert(0 &lt;= a &amp;&amp; a &lt; 2*n);
    assert(0 &lt;= b &amp;&amp; b &lt; 2*n);
    <I><FONT COLOR="#B22222">// union with splicing is a bit faster than 
</FONT></I>    <I><FONT COLOR="#B22222">// just path compression also guarantees p[i] &lt;= i
</FONT></I>    <B><FONT COLOR="#A020F0">while</FONT></B>(p[a] != p[b]){
      <B><FONT COLOR="#A020F0">if</FONT></B>(p[a] &lt; p[b]) swap(a, b);
      <B><FONT COLOR="#A020F0">if</FONT></B>(p[a] == a){
        p[a] = b;
        <B><FONT COLOR="#A020F0">return</FONT></B>;
      }
      <B><FONT COLOR="#228B22">int</FONT></B> tmp = p[a];
      p[a] = p[b];
      a = p[tmp];
    }
  }
  <B><FONT COLOR="#228B22">int</FONT></B> components(){
    <B><FONT COLOR="#228B22">int</FONT></B> ret = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;(<B><FONT COLOR="#228B22">int</FONT></B>)p.size();++i)
      <B><FONT COLOR="#A020F0">if</FONT></B>(p[i] == i) ++ret;
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
  }
  <I><FONT COLOR="#B22222">// call this after adding all queries
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> compute(){
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; p2(2*n);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> l=m-1; l&gt;=0; --l){
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> s = 1&lt;&lt;l;
      <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;2*n; ++i) p2[i] = f(i);
      <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0; i+s&lt;2*n; ++i){
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j = p2[i];
        <B><FONT COLOR="#A020F0">if</FONT></B>(j+s &lt; 2*n) u(i+s, j+s);
      }
      <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B>&amp;e:qs[l])
        u(e.first, e.second);
    }
    <I><FONT COLOR="#B22222">// link point with mirror-image
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i)
      u(i, 2*n-1 - i);
  }
  <I><FONT COLOR="#B22222">// force [l, r] to be a palindrome
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> add_q(<B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r){
    assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt; n);
    <B><FONT COLOR="#A020F0">if</FONT></B>(l==r) <B><FONT COLOR="#A020F0">return</FONT></B>;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> range = r-l+1;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k = __lg(range);
    qs[k].emplace_back(l, 2*n-1 - r);
  }
  <B><FONT COLOR="#228B22">int</FONT></B> n, m;
  vector&lt;vector&lt;pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; &gt; qs;
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; p;
};</PRE>
<HR>
<A NAME="file31">
<H1>code/eertree.cc 31/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file30">prev</A>][<A HREF="#file32">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/*
Palindrome tree. Useful structure to deal with palindromes in strings. O(N)
This code counts no. of palindrome substrings of string. Based on problem 1750 from informatics.mccme.ru:
http://informatics.mccme.ru/moodle/mod/statements/view.php?chapterid =1750
*/</FONT></I>

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MAXN = 105000;

<B><FONT COLOR="#228B22">struct</FONT></B> node {
    <B><FONT COLOR="#228B22">int</FONT></B> next[26];
    <B><FONT COLOR="#228B22">int</FONT></B> len;
    <B><FONT COLOR="#228B22">int</FONT></B> sufflink;
    <B><FONT COLOR="#228B22">int</FONT></B> num;
};
<B><FONT COLOR="#228B22">int</FONT></B> len;
<B><FONT COLOR="#228B22">char</FONT></B> s[MAXN];
node tree[MAXN]; 
<B><FONT COLOR="#228B22">int</FONT></B> num;            <I><FONT COLOR="#B22222">// node 1 - root with len -1, node 2 - root with len 0
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> suff;           <I><FONT COLOR="#B22222">// max suffix palindrome
</FONT></I><B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ans;

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">addLetter</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> pos) {
    <B><FONT COLOR="#228B22">int</FONT></B> cur = suff, curlen = 0;
    <B><FONT COLOR="#228B22">int</FONT></B> let = s[pos] - <B><FONT COLOR="#BC8F8F">'a'</FONT></B>;
    <B><FONT COLOR="#A020F0">while</FONT></B> (true) {
        curlen = tree[cur].len;
        <B><FONT COLOR="#A020F0">if</FONT></B> (pos - 1 - curlen &gt;= 0 &amp;&amp; s[pos - 1 - curlen] == s[pos])     
            <B><FONT COLOR="#A020F0">break</FONT></B>;  
        cur = tree[cur].sufflink;
    }       
    <B><FONT COLOR="#A020F0">if</FONT></B> (tree[cur].next[let]) {  
        suff = tree[cur].next[let];
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    num++;
    suff = num;
    tree[num].len = tree[cur].len + 2;
    tree[cur].next[let] = num;
    <B><FONT COLOR="#A020F0">if</FONT></B> (tree[num].len == 1) {
        tree[num].sufflink = 2;
        tree[num].num = 1;
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#A020F0">while</FONT></B> (true) {
        cur = tree[cur].sufflink;
        curlen = tree[cur].len;
        <B><FONT COLOR="#A020F0">if</FONT></B> (pos - 1 - curlen &gt;= 0 &amp;&amp; s[pos - 1 - curlen] == s[pos]) {
            tree[num].sufflink = tree[cur].next[let];
            <B><FONT COLOR="#A020F0">break</FONT></B>;
        }       
    }           
    tree[num].num = 1 + tree[tree[num].sufflink].num;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">initTree</FONT></B>() {
    num = 2; suff = 2;
    tree[1].len = -1; tree[1].sufflink = 1;
    tree[2].len = 0; tree[2].sufflink = 1;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    gets(s);
    len = strlen(s)
    initTree()
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; len; i++) {
        addLetter(i);
        ans += tree[suff].num;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}</PRE>
<HR>
<A NAME="file32">
<H1>code/BITRange.cc 32/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file31">prev</A>][<A HREF="#file33">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> BIT {

  <B><FONT COLOR="#228B22">int</FONT></B> n;
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; slope;
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; intercept;

  <I><FONT COLOR="#B22222">// BIT can be thought of as having entries f[1], ..., f[n] which are 0-initialized
</FONT></I>  BIT(<B><FONT COLOR="#228B22">int</FONT></B> n): n(n), slope(n+1), intercept(n+1) {}
  <I><FONT COLOR="#B22222">// returns f[1] + ... + f[idx-1]
</FONT></I>  <I><FONT COLOR="#B22222">// precondition idx &lt;= n+1
</FONT></I>
  <B><FONT COLOR="#228B22">int</FONT></B> query(<B><FONT COLOR="#228B22">int</FONT></B> idx) {
    <B><FONT COLOR="#228B22">int</FONT></B> m = 0, b = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = idx-1; i &gt; 0; i -= i&amp;-i) {
      m += slope[i];
      b += intercept[i];
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> m*idx + b;
  }

  <I><FONT COLOR="#B22222">// adds amt to f[i] for i in [idx1, idx2)
</FONT></I>  <I><FONT COLOR="#B22222">// precondition 1 &lt;= idx1 &lt;= idx2 &lt;= n+1 (you can't update element 0)
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> idx1, <B><FONT COLOR="#228B22">int</FONT></B> idx2, <B><FONT COLOR="#228B22">int</FONT></B> amt) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = idx1; i &lt;= n; i += i&amp;-i) {
      slope[i] += amt;
      intercept[i] -= idx1*amt;
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = idx2; i &lt;= n; i += i&amp;-i) {
      slope[i] -= amt;
      intercept[i] += idx2*amt;
    }
  }
  
};</PRE>
<HR>
<A NAME="file33">
<H1>code/treap.cpp 33/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file32">prev</A>][<A HREF="#file34">next</A>]
<PRE>
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> node{
  <B><FONT COLOR="#228B22">int</FONT></B> prior,size;
  <B><FONT COLOR="#228B22">int</FONT></B> val;<I><FONT COLOR="#B22222">//value stored in the array
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> sum;<I><FONT COLOR="#B22222">//whatever info you want to maintain in segtree for each node
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> lazy;<I><FONT COLOR="#B22222">//whatever lazy update you want to do
</FONT></I>  <B><FONT COLOR="#228B22">struct</FONT></B> node *l,*r;
} node;

<B><FONT COLOR="#228B22">struct</FONT></B> Treap {
  <B><FONT COLOR="#228B22">typedef</FONT></B> node* pnode;
  <B><FONT COLOR="#228B22">int</FONT></B> sz(pnode t){
    <B><FONT COLOR="#A020F0">return</FONT></B> t?t-&gt;size:0;
  }
  <B><FONT COLOR="#228B22">void</FONT></B> upd_sz(pnode t){
    <B><FONT COLOR="#A020F0">if</FONT></B>(t)t-&gt;size=sz(t-&gt;l)+1+sz(t-&gt;r);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> lazy(pnode t){
    <B><FONT COLOR="#A020F0">if</FONT></B>(!t || !t-&gt;lazy)<B><FONT COLOR="#A020F0">return</FONT></B>;
    t-&gt;val+=t-&gt;lazy;<I><FONT COLOR="#B22222">//operation of lazy
</FONT></I>    t-&gt;sum+=t-&gt;lazy*sz(t);
    <B><FONT COLOR="#A020F0">if</FONT></B>(t-&gt;l)t-&gt;l-&gt;lazy+=t-&gt;lazy;<I><FONT COLOR="#B22222">//propagate lazy
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(t-&gt;r)t-&gt;r-&gt;lazy+=t-&gt;lazy;
    t-&gt;lazy=0;
  }
  <B><FONT COLOR="#228B22">void</FONT></B> reset(pnode t){
    <B><FONT COLOR="#A020F0">if</FONT></B>(t)t-&gt;sum = t-&gt;val;<I><FONT COLOR="#B22222">//no need to reset lazy coz when we call this lazy would itself be propagated
</FONT></I>  }
  <B><FONT COLOR="#228B22">void</FONT></B> combine(pnode&amp; t,pnode l,pnode r){<I><FONT COLOR="#B22222">//combining two ranges of segtree
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!l || !r)<B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>(t = l?l:r);
    t-&gt;sum = l-&gt;sum + r-&gt;sum;
  }
  <B><FONT COLOR="#228B22">void</FONT></B> operation(pnode t){<I><FONT COLOR="#B22222">//operation of segtree
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(!t)<B><FONT COLOR="#A020F0">return</FONT></B>;
    reset(t);<I><FONT COLOR="#B22222">//reset the value of current node assuming it now represents a single element of the array
</FONT></I>    lazy(t-&gt;l);lazy(t-&gt;r);<I><FONT COLOR="#B22222">//imp:propagate lazy before combining t-&gt;l,t-&gt;r;
</FONT></I>    combine(t,t-&gt;l,t);
    combine(t,t,t-&gt;r);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> split(pnode t,pnode &amp;l,pnode &amp;r,<B><FONT COLOR="#228B22">int</FONT></B> pos,<B><FONT COLOR="#228B22">int</FONT></B> add=0){
    <B><FONT COLOR="#A020F0">if</FONT></B>(!t)<B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>(l=r=NULL);
    lazy(t);
    <B><FONT COLOR="#228B22">int</FONT></B> curr_pos = add + sz(t-&gt;l);
    <B><FONT COLOR="#A020F0">if</FONT></B>(curr_pos&lt;=pos)<I><FONT COLOR="#B22222">//element at pos goes to left subtree(l)
</FONT></I>      split(t-&gt;r,t-&gt;r,r,pos,curr_pos+1),l=t;
    <B><FONT COLOR="#A020F0">else</FONT></B> 
      split(t-&gt;l,l,t-&gt;l,pos,add),r=t;
    upd_sz(t);
    operation(t);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> merge(pnode &amp;t,pnode l,pnode r){ <I><FONT COLOR="#B22222">//l-&gt;leftarray,r-&gt;rightarray,t-&gt;resulting array
</FONT></I>    lazy(l);lazy(r);
    <B><FONT COLOR="#A020F0">if</FONT></B>(!l || !r) t = l?l:r;
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(l-&gt;prior&gt;r-&gt;prior)merge(l-&gt;r,l-&gt;r,r),t=l;
    <B><FONT COLOR="#A020F0">else</FONT></B>    merge(r-&gt;l,l,r-&gt;l),t=r;
    upd_sz(t);
    operation(t);
  }
  pnode init(<B><FONT COLOR="#228B22">int</FONT></B> val){
    pnode ret = (pnode)malloc(<B><FONT COLOR="#A020F0">sizeof</FONT></B>(node));
    ret-&gt;prior=rand();ret-&gt;size=1;
    ret-&gt;val=val;
    ret-&gt;sum=val;ret-&gt;lazy=0;
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
  }
  <B><FONT COLOR="#228B22">int</FONT></B> range_query(pnode t,<B><FONT COLOR="#228B22">int</FONT></B> l,<B><FONT COLOR="#228B22">int</FONT></B> r){<I><FONT COLOR="#B22222">//[l,r]
</FONT></I>    pnode L,mid,R;
    split(t,L,mid,l-1);
    split(mid,t,R,r-l);<I><FONT COLOR="#B22222">//note: r-l!!
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> ans = t-&gt;sum;
    merge(mid,L,t);
    merge(t,mid,R);
    <B><FONT COLOR="#A020F0">return</FONT></B> ans;
  }
  <B><FONT COLOR="#228B22">void</FONT></B> range_update(pnode t,<B><FONT COLOR="#228B22">int</FONT></B> l,<B><FONT COLOR="#228B22">int</FONT></B> r,<B><FONT COLOR="#228B22">int</FONT></B> val){<I><FONT COLOR="#B22222">//[l,r]
</FONT></I>    pnode L,mid,R;
    split(t,L,mid,l-1);
    split(mid,t,R,r-l);<I><FONT COLOR="#B22222">//note: r-l!!
</FONT></I>    t-&gt;lazy+=val; <I><FONT COLOR="#B22222">//lazy_update
</FONT></I>    merge(mid,L,t);
    merge(t,mid,R);
  }
};</PRE>
<HR>
<A NAME="file34">
<H1>code/link_cut.cc 34/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file33">prev</A>][<A HREF="#file35">next</A>]
<PRE>
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MXN = 100005, MEM = 100005;
<B><FONT COLOR="#228B22">struct</FONT></B> Splay {
  <B><FONT COLOR="#228B22">static</FONT></B> Splay nil, mem[MEM], *pmem;
  Splay *ch[2], *f;
  <B><FONT COLOR="#228B22">int</FONT></B> val, rev, size;
  Splay (<B><FONT COLOR="#228B22">int</FONT></B> _val=-1) : val(_val), rev(0), size(1)
  { f = ch[0] = ch[1] = &amp;nil; }
  <B><FONT COLOR="#228B22">bool</FONT></B> isr()
  { <B><FONT COLOR="#A020F0">return</FONT></B> f-&gt;ch[0] != <B><FONT COLOR="#A020F0">this</FONT></B> &amp;&amp; f-&gt;ch[1] != <B><FONT COLOR="#A020F0">this</FONT></B>; }
  <B><FONT COLOR="#228B22">int</FONT></B> dir()
  { <B><FONT COLOR="#A020F0">return</FONT></B> f-&gt;ch[0] == <B><FONT COLOR="#A020F0">this</FONT></B> ? 0 : 1; }
  <B><FONT COLOR="#228B22">void</FONT></B> setCh(Splay *c, <B><FONT COLOR="#228B22">int</FONT></B> d){
    ch[d] = c;
    <B><FONT COLOR="#A020F0">if</FONT></B> (c != &amp;nil) c-&gt;f = <B><FONT COLOR="#A020F0">this</FONT></B>;
    pull();
  }
  <B><FONT COLOR="#228B22">void</FONT></B> push(){
    <B><FONT COLOR="#A020F0">if</FONT></B>( !rev ) <B><FONT COLOR="#A020F0">return</FONT></B>;
    swap(ch[0], ch[1]);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ch[0] != &amp;nil) ch[0]-&gt;rev ^= 1;
    <B><FONT COLOR="#A020F0">if</FONT></B> (ch[1] != &amp;nil) ch[1]-&gt;rev ^= 1;
    rev=0;
  }
  <B><FONT COLOR="#228B22">void</FONT></B> pull(){
    size = ch[0]-&gt;size + ch[1]-&gt;size + 1;
    <B><FONT COLOR="#A020F0">if</FONT></B> (ch[0] != &amp;nil) ch[0]-&gt;f = <B><FONT COLOR="#A020F0">this</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (ch[1] != &amp;nil) ch[1]-&gt;f = <B><FONT COLOR="#A020F0">this</FONT></B>;
  }
} Splay::nil, Splay::mem[MEM], *Splay::pmem = Splay::mem;
Splay *nil = &amp;Splay::nil;
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">rotate</FONT></B>(Splay *x){
  Splay *p = x-&gt;f;
  <B><FONT COLOR="#228B22">int</FONT></B> d = x-&gt;dir();
  <B><FONT COLOR="#A020F0">if</FONT></B> (!p-&gt;isr()) p-&gt;f-&gt;setCh(x, p-&gt;dir());
  <B><FONT COLOR="#A020F0">else</FONT></B> x-&gt;f = p-&gt;f;
	p-&gt;setCh(x-&gt;ch[!d], d); x-&gt;setCh(p, !d); p-&gt;pull(); x-&gt;pull();
}
vector&lt;Splay*&gt; splayVec;
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">splay</FONT></B>(Splay *x){
  splayVec.clear();
  <B><FONT COLOR="#A020F0">for</FONT></B>(Splay *q=x;; q=q-&gt;f){
    splayVec.push_back(q);
    <B><FONT COLOR="#A020F0">if</FONT></B> (q-&gt;isr()) <B><FONT COLOR="#A020F0">break</FONT></B>;
  }
  reverse(begin(splayVec), end(splayVec));
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> it : splayVec) it-&gt;push();
  <B><FONT COLOR="#A020F0">while</FONT></B> (!x-&gt;isr())
    <B><FONT COLOR="#A020F0">if</FONT></B> (x-&gt;f-&gt;isr()) rotate(x);
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (x-&gt;dir()==x-&gt;f-&gt;dir()) rotate(x-&gt;f),rotate(x);
    <B><FONT COLOR="#A020F0">else</FONT></B> rotate(x),rotate(x);
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">id</FONT></B>(Splay *x) { <B><FONT COLOR="#A020F0">return</FONT></B> x - Splay::mem + 1; }
Splay* <B><FONT COLOR="#0000FF">access</FONT></B>(Splay *x){
  Splay *q = nil;
  <B><FONT COLOR="#A020F0">for</FONT></B> (;x!=nil;x=x-&gt;f) {splay(x); x-&gt;setCh(q, 1); q = x; }
  <B><FONT COLOR="#A020F0">return</FONT></B> q;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">chroot</FONT></B>(Splay *x){
  access(x); splay(x); x-&gt;rev ^= 1; x-&gt;push(); x-&gt;pull();
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">link</FONT></B>(Splay *x, Splay *y){
  access(x); splay(x);
  chroot(y); x-&gt;setCh(y, 1);
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">cut_p</FONT></B>(Splay *y) {
  access(y); splay(y); y-&gt;push(); y-&gt;ch[0] = y-&gt;ch[0]-&gt;f = nil;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">cut</FONT></B>(Splay *x, Splay *y){
  chroot(x); cut_p(y);
}
Splay* <B><FONT COLOR="#0000FF">get_root</FONT></B>(Splay *x) {
  access(x); splay(x);
  <B><FONT COLOR="#A020F0">for</FONT></B>(; x-&gt;ch[0] != nil; x = x-&gt;ch[0]) x-&gt;push();
  splay(x); <B><FONT COLOR="#A020F0">return</FONT></B> x;
}
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">conn</FONT></B>(Splay *x, Splay *y) {
  <B><FONT COLOR="#A020F0">return</FONT></B> (x = get_root(x)) == (y = get_root(y));
}
Splay* <B><FONT COLOR="#0000FF">lca</FONT></B>(Splay *x, Splay *y) {
  access(x); access(y); splay(x);
  <B><FONT COLOR="#A020F0">if</FONT></B> (x-&gt;f == nil) <B><FONT COLOR="#A020F0">return</FONT></B> x;
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">return</FONT></B> x-&gt;f;
}</PRE>
<HR>
<A NAME="file35">
<H1>code/2SAT.cc 35/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file34">prev</A>][<A HREF="#file36">next</A>]
<PRE>
<B><FONT COLOR="#228B22">class</FONT></B> Two_Sat {
  <B><FONT COLOR="#228B22">int</FONT></B> N; <I><FONT COLOR="#B22222">// number of variables
</FONT></I>  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; val; <I><FONT COLOR="#B22222">// assignment of x is at val[2x] and -x at val[2x+1]
</FONT></I>  vector&lt;<B><FONT COLOR="#228B22">char</FONT></B>&gt; valid; <I><FONT COLOR="#B22222">// changes made at time i are kept iff valid[i]
</FONT></I>  vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; G; <I><FONT COLOR="#B22222">// graph of implications G[x][i] = y means (x -&gt; y)
</FONT></I>  Two_Sat(<B><FONT COLOR="#228B22">int</FONT></B> N_) : N(N_) { <I><FONT COLOR="#B22222">// create a formula over N variables (numbered 1 to N)
</FONT></I>    G.resize(2*N);
  }
  <B><FONT COLOR="#228B22">int</FONT></B> add_variable() {
    G.emplace_back(); G.emplace_back();
    <B><FONT COLOR="#A020F0">return</FONT></B> N++;
  }
<B><FONT COLOR="#228B22">private</FONT></B>:
  <I><FONT COLOR="#B22222">// converts a signed variable index to its position in val[] and G[]
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> to_ind(<B><FONT COLOR="#228B22">int</FONT></B> x) {
    <B><FONT COLOR="#A020F0">return</FONT></B> 2*(abs(x)-1) + (x&lt;0);
  }
  <I><FONT COLOR="#B22222">// Add a directed edge to the graph.
</FONT></I>  <I><FONT COLOR="#B22222">// You most likely do not want to call this yourself!
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> add_edge(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    G[to_ind(a)].push_back(to_ind(b));
  }
  <B><FONT COLOR="#228B22">int</FONT></B> time() {
    <B><FONT COLOR="#A020F0">return</FONT></B> valid.size()-1;
  }
  <B><FONT COLOR="#228B22">bool</FONT></B> dfs(<B><FONT COLOR="#228B22">int</FONT></B> x) {
    <B><FONT COLOR="#A020F0">if</FONT></B>(valid[abs(val[x])]) <B><FONT COLOR="#A020F0">return</FONT></B> val[x]&gt;0;
    val[x] = time();
    val[x^1] = -time();
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> e:G[x])
      <B><FONT COLOR="#A020F0">if</FONT></B>(!dfs(e))
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
  }
<B><FONT COLOR="#228B22">public</FONT></B>:
  <I><FONT COLOR="#B22222">// Add the or-clause: (a or b)
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> add_or(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    add_edge(-a,b); add_edge(-b,a);
  }
  <I><FONT COLOR="#B22222">// Add the implication: a -&gt; b
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> add_implication(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    add_or(-a, b);
  }
  <I><FONT COLOR="#B22222">// Add condition: x is true
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> add_true(<B><FONT COLOR="#228B22">int</FONT></B> x) {
    add_or(x,x);
  }
  <I><FONT COLOR="#B22222">// At most one with linear number of clauses
</FONT></I>  <B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
  <B><FONT COLOR="#228B22">void</FONT></B> add_at_most_one(T vars) {
    <B><FONT COLOR="#A020F0">if</FONT></B>(vars.begin() == vars.end()) <B><FONT COLOR="#A020F0">return</FONT></B>;
    <B><FONT COLOR="#228B22">int</FONT></B> last = *vars.begin(), cur = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B>&amp;e:vars){
      <B><FONT COLOR="#A020F0">if</FONT></B>(e == last) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      <B><FONT COLOR="#A020F0">if</FONT></B>(cur == 0) cur = e;
      <B><FONT COLOR="#A020F0">else</FONT></B> {
        add_or(-cur, -e);
        <B><FONT COLOR="#228B22">int</FONT></B> new_cur = add_variable();
        cur = add_implication(cur, new_cur);
        add_implication(e, new_cur);
        cur = new_cur;
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(cur != 0) add_or(-cur, -last);
  }
  <B><FONT COLOR="#228B22">bool</FONT></B> solve() {
    val.assign(2*n, 0); valid.assign(1, 0);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;val.size(); i+=2) {
      <B><FONT COLOR="#A020F0">if</FONT></B>(!valid[abs(val[i])]) {
        valid.push_back(1);
        <B><FONT COLOR="#A020F0">if</FONT></B>(!dfs(i)) {
          valid.back()=0;
          valid.push_back(1);
          <B><FONT COLOR="#A020F0">if</FONT></B>(!dfs(i+1)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
      }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
  }
};</PRE>
<HR>
<A NAME="file36">
<H1>code/merge_insertion.cpp 36/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file35">prev</A>][<A HREF="#file37">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Sorting in O(n^2) time with near-optimal number of comparisons
</FONT></I><I><FONT COLOR="#B22222">// Number of comparisons used is: n lg n - 1.415 n
</FONT></I><I><FONT COLOR="#B22222">// The lower bound is: lg (n!) = n lg n - 1.443 n
</FONT></I><I><FONT COLOR="#B22222">// Binary search insertion sort would need: n log n - n
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> Merge_Insertion_Sort{
  <B><FONT COLOR="#228B22">template</FONT></B>&lt;typename F&gt;
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> apply_permutation(vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; <B><FONT COLOR="#228B22">const</FONT></B>&amp;p, F get){
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = p.size();
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q(n);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i) q[p[i]] = i;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i){
      <B><FONT COLOR="#A020F0">while</FONT></B>(q[i] != i){
        swap(get(i), get(q[i]));
        swap(q[i], q[q[i]]);
      }
    }
  }
  <I><FONT COLOR="#B22222">// ret.first is the sorted vector ret.second[i] is the 
</FONT></I>  <I><FONT COLOR="#B22222">// index of the i-th smallest element in the original vector
</FONT></I>  <I><FONT COLOR="#B22222">// i.e. ret.second is the permutation that was applied to sort
</FONT></I>  <B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T, typename F&gt;
  <B><FONT COLOR="#228B22">static</FONT></B> pair&lt;vector&lt;T&gt;, vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; sort(vector&lt;T&gt; v, F comp){
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = v.size();
    <B><FONT COLOR="#A020F0">if</FONT></B>(n &lt;= 1) <B><FONT COLOR="#A020F0">return</FONT></B> {move(v), {{0}}};
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; preperm(n);
    iota(preperm.begin(), preperm.end(), 0);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> M = n-n/2;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n/2;++i){
      <B><FONT COLOR="#A020F0">if</FONT></B>(comp(v[M+i], v[i])){
        swap(v[M+i], v[i]);
        swap(preperm[M+i], preperm[i]);
      }
    }
    <B><FONT COLOR="#228B22">auto</FONT></B> ret=sort(vector&lt;T&gt;(v.begin(),v.begin()+n/2),comp);
    apply_permutation(ret.second,[&amp;preperm,M](<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B>&amp;i)-&gt;<B><FONT COLOR="#228B22">int</FONT></B>&amp;{<B><FONT COLOR="#A020F0">return</FONT></B> preperm[M+i];});
    apply_permutation(ret.second,[&amp;preperm](<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B>&amp;i)-&gt;<B><FONT COLOR="#228B22">int</FONT></B>&amp;{<B><FONT COLOR="#A020F0">return</FONT></B> preperm[i];});
    apply_permutation(ret.second,[&amp;v,M](<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B>&amp;i)-&gt;T&amp;{<B><FONT COLOR="#A020F0">return</FONT></B> v[M+i];});
    iota(ret.second.begin(), ret.second.end(), 0);
    <I><FONT COLOR="#B22222">// insert one element without comparisons
</FONT></I>    ret.first.push_back(v.back());
    ret.second.push_back(n-1);
    <I><FONT COLOR="#B22222">// now insert the rest in blocks that optimize the binary search sizes
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> it=1,r=n-1,s=2; r&gt;n/2; ++it, r-=s, s=(1&lt;&lt;it)-s){
      <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=r-s;i&lt;r;++i){
        <B><FONT COLOR="#A020F0">if</FONT></B>(i&gt;=n/2){
          <B><FONT COLOR="#228B22">int</FONT></B> a = find(ret.second.begin(), ret.second.end(), i-M) - ret.second.begin();
          <B><FONT COLOR="#228B22">int</FONT></B> b = ret.first.size();
          <B><FONT COLOR="#A020F0">if</FONT></B>(a==b) {
            assert(i==M-1);
            a = -1;
          }
          <B><FONT COLOR="#A020F0">while</FONT></B>(a+1 &lt; b){
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = a+(b-a)/2;
            <B><FONT COLOR="#A020F0">if</FONT></B>(comp(ret.first[m], v[i])) a = m;
            <B><FONT COLOR="#A020F0">else</FONT></B> b = m;
          }
          ret.first.insert(ret.first.begin()+b, v[i]);
          ret.second.insert(ret.second.begin()+b, i);
        }
      }
    }
    <I><FONT COLOR="#B22222">// compose permutations
</FONT></I>    apply_permutation(ret.second, [&amp;preperm](<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B>&amp;i)-&gt;<B><FONT COLOR="#228B22">int</FONT></B>&amp;{<B><FONT COLOR="#A020F0">return</FONT></B> preperm[i];});
    ret.second.swap(preperm);
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
  }
  <B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
  <B><FONT COLOR="#228B22">static</FONT></B> pair&lt;vector&lt;T&gt;, vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; sort(vector&lt;T&gt; v){
    <B><FONT COLOR="#A020F0">return</FONT></B> sort(move(v), std::less&lt;T&gt;{});
  }
};</PRE>
<HR>
<A NAME="file37">
<H1>code/DP_optimizations.txt 37/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file36">prev</A>][<A HREF="#file38">next</A>]
<PRE>
A[i][j] : The smallest k that gives optimal answer

Divide and Conquer:
  dp[i][j] = min(k &lt; j){dp[i - 1][k] + C[k][j]}
  O(kn^2) -&gt; O(knlog(n))

  Conditions:
    A[i][j] &lt;= A[i][j + 1] OR
    C[a][d] + C[b][c] &gt;= C[a][c] + C[b][d] where a &lt; b &lt; c &lt; d

  Short Description:
    A[i][1] &lt;= A[i][2] &lt;= ... &lt;= A[i][n]

Knuth Optimization:
  dp[i][j] = min(i &lt; k &lt; j){dp[i][k] + dp[k][j]} + C[i][j] 
  O(n^3) -&gt; O(n^2)

  Conditions:
    A[i, j - 1] &lt;= A[i, j] &lt;= A[i + 1, j] OR
    C[a][d] + C[b][c] &gt;= C[a][c] + C[b][d] AND
    C[b][c] &lt;= C[a][d] where a &lt;= b &lt;= c &lt;= d

  Short Description:
    For dp[i][j], loop k from A[i][j - 1] to A[i + 1][j]</PRE>
<HR>
<A NAME="file38">
<H1>code/CHT.cc 38/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file37">prev</A>][<A HREF="#file39">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> Line {
  <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> m, b;
  mutable function&lt;<B><FONT COLOR="#228B22">const</FONT></B> Line*()&gt; succ;
  <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> Line&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B>{
    <B><FONT COLOR="#A020F0">if</FONT></B>(rhs.b!=-(1ll&lt;&lt;62)) <B><FONT COLOR="#A020F0">return</FONT></B> m&gt;rhs.m; <I><FONT COLOR="#B22222">// &lt; for max
</FONT></I>    <B><FONT COLOR="#228B22">const</FONT></B> Line* s = succ();
    <B><FONT COLOR="#A020F0">if</FONT></B> (!s) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    <B><FONT COLOR="#A020F0">return</FONT></B> b-s-&gt;b &gt; (s-&gt;m -m)*rhs.m; <I><FONT COLOR="#B22222">// &lt; for max
</FONT></I>  }
};
<B><FONT COLOR="#228B22">struct</FONT></B> HullDynamic : <B><FONT COLOR="#228B22">public</FONT></B> multiset&lt;Line&gt; {
  <B><FONT COLOR="#228B22">bool</FONT></B> bad(iterator y) {
    <B><FONT COLOR="#228B22">auto</FONT></B> z = next(y);
    <B><FONT COLOR="#A020F0">if</FONT></B>(y==begin()){
      <B><FONT COLOR="#A020F0">if</FONT></B>(z==end())<B><FONT COLOR="#A020F0">return</FONT></B> 0;
      <B><FONT COLOR="#A020F0">return</FONT></B> y-&gt;m == z-&gt;m &amp;&amp; y-&gt;b &gt;= z-&gt;b; <I><FONT COLOR="#B22222">// &lt;= for max
</FONT></I>    }
    <B><FONT COLOR="#228B22">auto</FONT></B> x = prev(y);
    <B><FONT COLOR="#A020F0">if</FONT></B> (z==end()) <B><FONT COLOR="#A020F0">return</FONT></B> y-&gt;m == x-&gt;m &amp;&amp; y-&gt;b &gt;= x-&gt;b;  <I><FONT COLOR="#B22222">// &lt;= for max
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> (x-&gt;b - y-&gt;b)*1.0*(z-&gt;m - y-&gt;m) &gt;= (y-&gt;b - z-&gt;b)*1.0*(y-&gt;m - x-&gt;m); 
  }
  <B><FONT COLOR="#228B22">void</FONT></B> insert_line(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> m, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> b) {
    <B><FONT COLOR="#228B22">auto</FONT></B> y = insert({ m, b });
    y-&gt;succ = [=]{<B><FONT COLOR="#A020F0">return</FONT></B> next(y)==end()? 0:&amp;*next(y);};
    <B><FONT COLOR="#A020F0">if</FONT></B>(bad(y)) { erase(y); <B><FONT COLOR="#A020F0">return</FONT></B>; }
    <B><FONT COLOR="#A020F0">while</FONT></B>(next(y)!=end() &amp;&amp; bad(next(y)))erase(next(y));
    <B><FONT COLOR="#A020F0">while</FONT></B>(y!=begin() &amp;&amp; bad(prev(y)))erase(prev(y));
  }
  <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> eval(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> x) {
    <B><FONT COLOR="#228B22">auto</FONT></B> l = *lower_bound((Line){x,-(1ll&lt;&lt;62)});
    <B><FONT COLOR="#A020F0">return</FONT></B> l.m * x + l.b;
  }
};</PRE>
<HR>
<A NAME="file39">
<H1>code/ConvexHullStatic.cc 39/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file38">prev</A>][<A HREF="#file40">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> ConvexHullTrick {
  <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> LL;
  vector&lt;LL&gt; M;
  vector&lt;LL&gt; B;
  vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; left;
  ConvexHullTrick() {}
  <B><FONT COLOR="#228B22">bool</FONT></B> bad(LL m1, LL b1, LL m2, LL b2, LL m3, LL b3) {
    <I><FONT COLOR="#B22222">// Careful, this may overflow
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> (b3-b1)*(m1-m2) &lt; (b2-b1)*(m1-m3);
  }
  <I><FONT COLOR="#B22222">// Add a new line to the structure, y = mx + b.
</FONT></I>  <I><FONT COLOR="#B22222">// Lines must be added in decreasing order of slope.
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> add(LL m, LL b) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (M.size() &gt;= 2 &amp;&amp; bad(M[M.size()-2], B[B.size()-2], M.back(), B.back(), m, b)) {
      M.pop_back(); B.pop_back(); left.pop_back();
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (M.size() &amp;&amp; M.back() == m) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (B.back() &gt; b) {
        M.pop_back(); B.pop_back(); left.pop_back();
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B>;
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (M.size() == 0) {
      left.push_back(-numeric_limits&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;::infinity());
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      left.push_back((<B><FONT COLOR="#228B22">double</FONT></B>)(b - B.back())/(M.back() - m));
    }
    M.push_back(m);
    B.push_back(b);
  }
  <I><FONT COLOR="#B22222">// Get the minimum value of mx + b among all lines in the structure.
</FONT></I>  <I><FONT COLOR="#B22222">// There must be at least one line.
</FONT></I>  LL query(LL x) {
    <B><FONT COLOR="#228B22">int</FONT></B> i = upper_bound(left.begin(), left.end(), x) - left.begin();
    <B><FONT COLOR="#A020F0">return</FONT></B> M[i-1]*x + B[i-1];
  }
};</PRE>
<HR>
<A NAME="file40">
<H1>code/bignum.cc 40/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file39">prev</A>][<A HREF="#file41">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> bignum {
  <B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> uint;
  vector&lt;uint&gt; digits;
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> uint RADIX = 1000000000;
  bignum(): digits(1, 0) {}
  bignum(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; x): digits(x.digits) {}
  bignum(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> x) {*<B><FONT COLOR="#A020F0">this</FONT></B> = x;}
  bignum(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* x) {*<B><FONT COLOR="#A020F0">this</FONT></B> = x;}
  bignum(<B><FONT COLOR="#228B22">const</FONT></B> string&amp; s) {*<B><FONT COLOR="#A020F0">this</FONT></B> = s;}
  bignum&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y)
    {digits = y.digits; <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;}
  bignum&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> x){
    digits.assign(1, x%RADIX);
    <B><FONT COLOR="#A020F0">if</FONT></B> (x &gt;= RADIX)
      digits.push_back(x/RADIX);
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
  }
  bignum&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* s) {
    <B><FONT COLOR="#228B22">int</FONT></B> slen=strlen(s),i,l;
    digits.resize((slen+8)/9);
    <B><FONT COLOR="#A020F0">for</FONT></B> (l=0; slen&gt;0; l++,slen-=9) {
      digits[l]=0;
      <B><FONT COLOR="#A020F0">for</FONT></B> (i=slen&gt;9?slen-9:0; i&lt;slen; i++)
        digits[l]=10*digits[l]+s[i]-<B><FONT COLOR="#BC8F8F">'0'</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">while</FONT></B> (digits.size() &gt; 1 &amp;&amp; !digits.back()) digits.pop_back();
    <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;
  }
  bignum&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> string&amp; s)
    {<B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B> = s.c_str();}

  <B><FONT COLOR="#228B22">void</FONT></B> add(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; x) {
    <B><FONT COLOR="#228B22">int</FONT></B> l = max(digits.size(), x.digits.size());
    digits.resize(l+1);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> d=0, carry=0; d&lt;=l; d++) {
      uint sum=carry;
      <B><FONT COLOR="#A020F0">if</FONT></B> (d&lt;digits.size()) sum+=digits[d];
      <B><FONT COLOR="#A020F0">if</FONT></B> (d&lt;x.digits.size()) sum+=x.digits[d];
      digits[d]=sum;
      <B><FONT COLOR="#A020F0">if</FONT></B> (digits[d]&gt;=RADIX)
        digits[d]-=RADIX, carry=1;
      <B><FONT COLOR="#A020F0">else</FONT></B>
        carry=0;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!digits.back()) digits.pop_back();
  }
  <B><FONT COLOR="#228B22">void</FONT></B> sub(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; x) {
    <I><FONT COLOR="#B22222">// if ((*this)&lt;x) throw; //negative numbers not yet supported
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> d=0, borrow=0; d&lt;digits.size(); d++) {
      digits[d]-=borrow;
      <B><FONT COLOR="#A020F0">if</FONT></B> (d&lt;x.digits.size()) digits[d]-=x.digits[d];
      <B><FONT COLOR="#A020F0">if</FONT></B> (digits[d]&gt;&gt;31) { digits[d]+=RADIX; borrow=1; } <B><FONT COLOR="#A020F0">else</FONT></B> borrow=0;
    }
    <B><FONT COLOR="#A020F0">while</FONT></B> (digits.size() &gt; 1 &amp;&amp; !digits.back()) digits.pop_back();
  }
  <B><FONT COLOR="#228B22">void</FONT></B> mult(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; x) {
    vector&lt;uint&gt; res(digits.size() + x.digits.size());
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> y,z;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;digits.size(); i++) {
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;x.digits.size(); j++) {
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> y=digits[i]; y*=x.digits[j];
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> z=y/RADIX;
        res[i+j+1]+=z; res[i+j]+=y-RADIX*z; <I><FONT COLOR="#B22222">//mod is slow
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (res[i+j] &gt;= RADIX) { res[i+j] -= RADIX; res[i+j+1]++; }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = i+j+1; res[k] &gt;= RADIX; res[k] -= RADIX, res[++k]++);
      }
    }
    digits = res;
    <B><FONT COLOR="#A020F0">while</FONT></B> (digits.size() &gt; 1 &amp;&amp; !digits.back()) digits.pop_back();
  }  
  <I><FONT COLOR="#B22222">// returns the remainder
</FONT></I>  bignum div(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; x) {
    bignum dividend(*<B><FONT COLOR="#A020F0">this</FONT></B>);
    bignum divisor(x);
    fill(digits.begin(), digits.end(), 0);
    <I><FONT COLOR="#B22222">// shift divisor up
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> pwr = dividend.digits.size() - divisor.digits.size();
    <B><FONT COLOR="#A020F0">if</FONT></B> (pwr &gt; 0) {
      divisor.digits.insert(divisor.digits.begin(), pwr, 0);
    }
    <B><FONT COLOR="#A020F0">while</FONT></B> (pwr &gt;= 0) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (dividend.digits.size() &gt; divisor.digits.size()) {
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> q = dividend.digits.back();
        q *= RADIX; q += dividend.digits[dividend.digits.size()-2];
        q /= 1+divisor.digits.back();
        dividend -= divisor*q; digits[pwr] = q;
        <B><FONT COLOR="#A020F0">if</FONT></B> (dividend &gt;= divisor) { digits[pwr]++; dividend -= divisor; }
        assert(dividend.digits.size() &lt;= divisor.digits.size()); <B><FONT COLOR="#A020F0">continue</FONT></B>;
      }
      <B><FONT COLOR="#A020F0">while</FONT></B> (dividend.digits.size() == divisor.digits.size()) {
        uint q = dividend.digits.back() / (1+divisor.digits.back());
        <B><FONT COLOR="#A020F0">if</FONT></B> (q == 0) <B><FONT COLOR="#A020F0">break</FONT></B>;
        digits[pwr] += q; dividend -= divisor*q;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (dividend &gt;= divisor) { dividend -= divisor; digits[pwr]++; }
      pwr--; divisor.digits.erase(divisor.digits.begin());
    }
    <B><FONT COLOR="#A020F0">while</FONT></B> (digits.size() &gt; 1 &amp;&amp; !digits.back()) digits.pop_back();
    <B><FONT COLOR="#A020F0">return</FONT></B> dividend;
  }
  
  string to_string() <B><FONT COLOR="#228B22">const</FONT></B> {
    ostringstream oss;
    oss &lt;&lt; digits.back();
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = digits.size() - 2; i &gt;= 0; i--) {
      oss &lt;&lt; setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) &lt;&lt; setw(9) &lt;&lt; digits[i];
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> oss.str();
  }
  bignum <B><FONT COLOR="#A020F0">operator</FONT></B>+(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y) <B><FONT COLOR="#228B22">const</FONT></B>
    {bignum res(*<B><FONT COLOR="#A020F0">this</FONT></B>); res.add(y); <B><FONT COLOR="#A020F0">return</FONT></B> res;}
  bignum <B><FONT COLOR="#A020F0">operator</FONT></B>-(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y) <B><FONT COLOR="#228B22">const</FONT></B>
    {bignum res(*<B><FONT COLOR="#A020F0">this</FONT></B>); res.sub(y); <B><FONT COLOR="#A020F0">return</FONT></B> res;}
  bignum <B><FONT COLOR="#A020F0">operator</FONT></B>*(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y) <B><FONT COLOR="#228B22">const</FONT></B> 
    {bignum res(*<B><FONT COLOR="#A020F0">this</FONT></B>); res.mult(y); <B><FONT COLOR="#A020F0">return</FONT></B> res;}
  bignum <B><FONT COLOR="#A020F0">operator</FONT></B>/(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y) <B><FONT COLOR="#228B22">const</FONT></B>
    {bignum res(*<B><FONT COLOR="#A020F0">this</FONT></B>); res.div(y); <B><FONT COLOR="#A020F0">return</FONT></B> res;}
  bignum <B><FONT COLOR="#A020F0">operator</FONT></B>%(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y) <B><FONT COLOR="#228B22">const</FONT></B>
    {bignum res(*<B><FONT COLOR="#A020F0">this</FONT></B>); <B><FONT COLOR="#A020F0">return</FONT></B> res.div(y);}
  bignum&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>+=(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y)
    {add(y); <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;}
  bignum&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>-=(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y)
    {sub(y); <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;}
  bignum&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>*=(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y)
    {mult(y); <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;}
  bignum&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>/=(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y)
    {div(y); <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B>;}
  bignum&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>%=(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y)
    {*<B><FONT COLOR="#A020F0">this</FONT></B> = div(y);}
  <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y)
    {<B><FONT COLOR="#A020F0">return</FONT></B> digits == y.digits;}
  <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y) <B><FONT COLOR="#228B22">const</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B> (digits.size() &lt; y.digits.size()) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">if</FONT></B> (digits.size() &gt; y.digits.size()) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = digits.size()-1; i &gt;= 0; i--)
      <B><FONT COLOR="#A020F0">if</FONT></B> (digits[i] &lt; y.digits[i])
        <B><FONT COLOR="#A020F0">return</FONT></B> true;
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (digits[i] &gt; y.digits[i])
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
  }
  <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y) <B><FONT COLOR="#228B22">const</FONT></B>
    {<B><FONT COLOR="#A020F0">return</FONT></B> y&lt;*<B><FONT COLOR="#A020F0">this</FONT></B>;}
  <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;=(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y) <B><FONT COLOR="#228B22">const</FONT></B>
    {<B><FONT COLOR="#A020F0">return</FONT></B> !(y&lt;*<B><FONT COLOR="#A020F0">this</FONT></B>);}
  <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&gt;=(<B><FONT COLOR="#228B22">const</FONT></B> bignum&amp; y) <B><FONT COLOR="#228B22">const</FONT></B> 
    {<B><FONT COLOR="#A020F0">return</FONT></B> !(*<B><FONT COLOR="#A020F0">this</FONT></B>&lt;y);}
};
</PRE>
<HR>
<A NAME="file41">
<H1>code/manacher.cpp 41/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file40">prev</A>][<A HREF="#file42">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Ex: &quot;opposes&quot; -&gt; [0,1,0,1,4,1,0,1,0,1,0,3,0,1,0]
</FONT></I>vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; fastLongestPalindromes(string str) {
  <B><FONT COLOR="#228B22">int</FONT></B> i=0,j,d,s,e,lLen,palLen=0;
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; res;
  <B><FONT COLOR="#A020F0">while</FONT></B> (i &lt; str.length()) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; palLen &amp;&amp; str[i-palLen-1] == str[i]) {
      palLen += 2; i++; <B><FONT COLOR="#A020F0">continue</FONT></B>;
    }
    res.push_back(palLen);
    s = res.size()-2;
    e = s-palLen;
    <B><FONT COLOR="#228B22">bool</FONT></B> b = true;
    <B><FONT COLOR="#A020F0">for</FONT></B> (j=s; j&gt;e; j--) {
      d = j-e-1;
      <B><FONT COLOR="#A020F0">if</FONT></B> (res[j] == d) { palLen = d; b = false; <B><FONT COLOR="#A020F0">break</FONT></B>; }
      res.push_back(min(d, res[j]));
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (b) { palLen = 1; i++; }
  }
  res.push_back(palLen);
  lLen = res.size();
  s = lLen-2;
  e = s-(2*str.length()+1-lLen);
  <B><FONT COLOR="#A020F0">for</FONT></B> (i=s; i&gt;e; i--) { d = i-e-1; res.push_back(min(d, res[i])); }
  <B><FONT COLOR="#A020F0">return</FONT></B> res;
}
</PRE>
<HR>
<A NAME="file42">
<H1>code/Dates.cc 42/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file41">prev</A>][<A HREF="#file43">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Months are expressed as integers from 1 to 12, Days are expressed as integers from 1 to 31, and Years are expressed as 4-digit integers.
</FONT></I>string dayOfWeek[] = {<B><FONT COLOR="#BC8F8F">&quot;Mon&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Tue&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Wed&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Thu&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Fri&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Sat&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Sun&quot;</FONT></B>};

<I><FONT COLOR="#B22222">//converts Gregorian date to integer(Julian day number)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">dateToInt</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> m, <B><FONT COLOR="#228B22">int</FONT></B> d, <B><FONT COLOR="#228B22">int</FONT></B> y){  
  <B><FONT COLOR="#A020F0">return</FONT></B> 
    1461 * (y + 4800 + (m - 14) / 12) / 4 +
    367 * (m - 2 - (m - 14) / 12 * 12) / 12 - 
    3 * ((y + 4900 + (m - 14) / 12) / 100) / 4 + 
    d - 32075;
}

<I><FONT COLOR="#B22222">// converts integer (Julian day number) to Gregorian date: month/day/year
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">intToDate</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> jd, <B><FONT COLOR="#228B22">int</FONT></B> &amp;m, <B><FONT COLOR="#228B22">int</FONT></B> &amp;d, <B><FONT COLOR="#228B22">int</FONT></B> &amp;y){
  <B><FONT COLOR="#228B22">int</FONT></B> x, n, i, j;
  x = jd + 68569;
  n = 4 * x / 146097;
  x -= (146097 * n + 3) / 4;
  i = (4000 * (x + 1)) / 1461001;
  x -= 1461 * i / 4 - 31;
  j = 80 * x / 2447;
  d = x - 2447 * j / 80;
  x = j / 11;
  m = j + 2 - 12 * x;
  y = 100 * (n - 49) + i + x;
}

<I><FONT COLOR="#B22222">// converts integer (Julian day number) to day of week
</FONT></I>string <B><FONT COLOR="#0000FF">intToDay</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> jd){
  <B><FONT COLOR="#A020F0">return</FONT></B> dayOfWeek[jd % 7];
}</PRE>
<HR>
<A NAME="file43">
<H1>code/Bitset.txt 43/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file42">prev</A>][<A HREF="#file44">next</A>]
<PRE>
Remember _Find_first() and _Find_next() ex- ist, and run in O(N/W), where W is word size of machine.</PRE>
<HR>
<A NAME="file44">
<H1>code/Template.cc 44/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file43">prev</A>][<A HREF="#file45">next</A>]
<PRE>
g++ -std=c++17 -DLOCAL -O2 -Wall -Wshadow -Wextra -pedantic -Wfloat-equal -Wlogical-op

#<B><FONT COLOR="#5F9EA0">pragma</FONT></B> <FONT COLOR="#B8860B">comment</FONT>(<FONT COLOR="#B8860B">linker</FONT>, <B><FONT COLOR="#BC8F8F">&quot;/stack:200000000&quot;</FONT></B>)
#<B><FONT COLOR="#5F9EA0">pragma</FONT></B> <FONT COLOR="#B8860B">GCC</FONT> <FONT COLOR="#B8860B">optimize</FONT>(<B><FONT COLOR="#BC8F8F">&quot;Ofast&quot;</FONT></B>)
#<B><FONT COLOR="#5F9EA0">pragma</FONT></B> <FONT COLOR="#B8860B">GCC</FONT> <FONT COLOR="#B8860B">optimize</FONT> (<B><FONT COLOR="#BC8F8F">&quot;unroll-loops&quot;</FONT></B>)
#<B><FONT COLOR="#5F9EA0">pragma</FONT></B> <FONT COLOR="#B8860B">GCC</FONT> <FONT COLOR="#B8860B">target</FONT>(<B><FONT COLOR="#BC8F8F">&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native&quot;</FONT></B>) // <FONT COLOR="#B8860B">codeforces</FONT>
<I><FONT COLOR="#B22222">//#pragma GCC target(&quot;avx,avx2,fma&quot;)
</FONT></I><I><FONT COLOR="#B22222">//#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native&quot;) // yandex
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ext/pb_ds/assoc_container.hpp&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ext/pb_ds/tree_policy.hpp&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
 
using namespace __gnu_pbds;
using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> ld;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ll;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair &lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; pii;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair &lt;ll, ll&gt; pll;

mt19937 <B><FONT COLOR="#0000FF">rng</FONT></B>(std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(chrono::high_resolution_clock::now().time_since_epoch()).count());

<B><FONT COLOR="#228B22">template</FONT></B>&lt;typename has_less&gt;
using ordered_set =
tree&lt;has_less,
	null_type,
	less&lt;has_less&gt;,
	rb_tree_tag,
	tree_order_statistics_node_update&gt;;

<I><FONT COLOR="#B22222">//insert using pref_trie.insert
</FONT></I><I><FONT COLOR="#B22222">//get range for prefix using pref_trie.prefix_range
</FONT></I><I><FONT COLOR="#B22222">//use iterator from range.first until != range.second
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B>
trie&lt;string,
	null_type,
	trie_string_access_traits&lt;&gt;,
	pat_trie_tag,
	trie_prefix_search_node_update&gt;
	pref_trie;

<B><FONT COLOR="#228B22">struct</FONT></B> chash {
    <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>()(<B><FONT COLOR="#228B22">int</FONT></B> x) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> x ^ RANDOM; }
};
gp_hash_table&lt;key, <B><FONT COLOR="#228B22">int</FONT></B>, chash&gt; table;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){}
</PRE>
<HR>
<A NAME="file45">
<H1>code/integration.cc 45/45</H1>
[<A HREF="#top">top</A>][<A HREF="#file44">prev</A>][next]
<PRE>
<I><FONT COLOR="#B22222">// different schemes for numerical integration
</FONT></I><I><FONT COLOR="#B22222">// approximatively ordered by accuracy
</FONT></I><I><FONT COLOR="#B22222">// do NOT use integer types for integration range!
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> Integration_Midpoint{
  <B><FONT COLOR="#228B22">template</FONT></B>&lt;typename Func, typename S&gt;
  <B><FONT COLOR="#228B22">static</FONT></B> typename result_of&lt;Func(S)&gt;::type integrate_step(Func f, S l, S r){
    S m = (l+r)/2;
    <B><FONT COLOR="#A020F0">return</FONT></B> f(m) * (r-l);
  }
};
<B><FONT COLOR="#228B22">struct</FONT></B> Integration_Simpson{
  <B><FONT COLOR="#228B22">template</FONT></B>&lt;typename Func, typename S&gt;
  <B><FONT COLOR="#228B22">static</FONT></B> typename result_of&lt;Func(S)&gt;::type integrate_step(Func f, S l, S r){
    S m = (l+r)/2;
    <B><FONT COLOR="#A020F0">return</FONT></B> (f(l) + 4*f(m) + f(r))/6 * (r-l);
  }
};
<B><FONT COLOR="#228B22">struct</FONT></B> Integration_Gauss_2{
  <B><FONT COLOR="#228B22">static</FONT></B> constexpr <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> A = 1.0l/sqrtl(3)/2, x1=0.5l-A, x2 = 0.5l+A;
  <B><FONT COLOR="#228B22">template</FONT></B>&lt;typename Func, typename S&gt;
  <B><FONT COLOR="#228B22">static</FONT></B> typename result_of&lt;Func(S)&gt;::type integrate_step(Func f, S l, S r){
    <B><FONT COLOR="#A020F0">return</FONT></B> (f(l*x1 + r*x2) + f(l*x2+r*x1))/2 * (r-l);
  }
};
<B><FONT COLOR="#228B22">struct</FONT></B> Integration_NCotes_Open_4{
  <B><FONT COLOR="#228B22">template</FONT></B>&lt;typename Func, typename S&gt;
  <B><FONT COLOR="#228B22">static</FONT></B> typename result_of&lt;Func(S)&gt;::type integrate_step(Func f, S l, S r){
    S h = (r-l)/5;
    <B><FONT COLOR="#A020F0">return</FONT></B> (11*f(l+h) + f(l+2*h) + f(r-2*h) + 11*f(r-h))/24 * (r-l);
  }
};
<B><FONT COLOR="#228B22">struct</FONT></B> Integration_Gauss_3{
  <B><FONT COLOR="#228B22">static</FONT></B> constexpr <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> A = sqrtl(3.0l/5.0l)/2, x1=0.5-A, x2 = 0.5+A;
  <B><FONT COLOR="#228B22">template</FONT></B>&lt;typename Func, typename S&gt;
  <B><FONT COLOR="#228B22">static</FONT></B> typename result_of&lt;Func(S)&gt;::type integrate_step(Func f, S l, S r){
    <B><FONT COLOR="#A020F0">return</FONT></B> (5*f(l*x1 + r*x2) + 8*f((l+r)/2) + 5*f(l*x2+r*x1))/18 * (r-l);
  }
};

<B><FONT COLOR="#228B22">template</FONT></B>&lt;typename Integration_Method&gt;
<B><FONT COLOR="#228B22">struct</FONT></B> Integrator_Fixedstep{
  <B><FONT COLOR="#228B22">template</FONT></B>&lt;typename Func, typename S&gt;
  <B><FONT COLOR="#228B22">static</FONT></B> typename result_of&lt;Func(S)&gt;::type integrate(Func f, S <B><FONT COLOR="#228B22">const</FONT></B> l, S <B><FONT COLOR="#228B22">const</FONT></B> r, size_t <B><FONT COLOR="#228B22">const</FONT></B> steps){
    assert(steps&gt;0);
    typename result_of&lt;Func(S)&gt;::type ret(0);
    S cur_l = l, cur_r;
    <B><FONT COLOR="#A020F0">for</FONT></B>(size_t i=0;i&lt;steps;++i){
      cur_r = (l*(steps-i-1) + r*(i+1))/steps;
      ret+=Integration_Method::integrate_step(f, cur_l, cur_r);
      cur_l = cur_r;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ret;
  }
};
<B><FONT COLOR="#228B22">template</FONT></B>&lt;typename Integration_Method&gt;
<B><FONT COLOR="#228B22">class</FONT></B> Integrator_Adaptive{
<B><FONT COLOR="#228B22">private</FONT></B>:
  <B><FONT COLOR="#228B22">template</FONT></B>&lt;size_t depth_limit, typename Func, typename S&gt;
  <B><FONT COLOR="#228B22">static</FONT></B> typename result_of&lt;Func(S)&gt;::type integrate(Func f, S <B><FONT COLOR="#228B22">const</FONT></B> l, S <B><FONT COLOR="#228B22">const</FONT></B> r, typename result_of&lt;Func(S)&gt;::type <B><FONT COLOR="#228B22">const</FONT></B> val, typename result_of&lt;Func(S)&gt;::type <B><FONT COLOR="#228B22">const</FONT></B> eps, <B><FONT COLOR="#228B22">const</FONT></B> size_t depth){
    <B><FONT COLOR="#A020F0">if</FONT></B>(depth&gt;=depth_limit){
      <B><FONT COLOR="#A020F0">return</FONT></B> val;
    }
    S <B><FONT COLOR="#228B22">const</FONT></B> m = (l+r)/2;
    typename result_of&lt;Func(S)&gt;::type val_l = Integration_Method::integrate_step(f, l, m);
    typename result_of&lt;Func(S)&gt;::type val_r = Integration_Method::integrate_step(f, m, r);
    typename result_of&lt;Func(S)&gt;::type error = abs(val - val_l - val_r);
    <B><FONT COLOR="#A020F0">if</FONT></B>(error &lt; eps){
      <B><FONT COLOR="#A020F0">return</FONT></B> val_l + val_r;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> integrate&lt;depth_limit&gt;(f, l, m, val_l, eps/2, depth+1)
      + integrate&lt;depth_limit&gt;(f, m, r, val_r, eps/2, depth+1);
  }
<B><FONT COLOR="#228B22">public</FONT></B>:
  <B><FONT COLOR="#228B22">template</FONT></B>&lt;size_t depth_limit, typename Func, typename S&gt;
  <B><FONT COLOR="#228B22">static</FONT></B> typename result_of&lt;Func(S)&gt;::type integrate(Func f, S <B><FONT COLOR="#228B22">const</FONT></B> l, S <B><FONT COLOR="#228B22">const</FONT></B> r, typename result_of&lt;Func(S)&gt;::type <B><FONT COLOR="#228B22">const</FONT></B> eps){
    <B><FONT COLOR="#A020F0">return</FONT></B> integrate&lt;depth_limit&gt;(f, l, r, Integration_Method::integrate_step(f, l, r), eps, 0);
  }
};</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.6</A>.</ADDRESS>
</BODY>
</HTML>
