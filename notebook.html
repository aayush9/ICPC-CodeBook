<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>Stanford ACM-ICPC Team Notebook</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<CENTER><H1><U>Stanford ACM-ICPC Team Notebook</U></H1></CENTER>
<H1>Table of Contents</H1>
<H2>Combinatorial optimization</H2>

<OL START=1>
<LI><A HREF="#file1">Dinic's</A></LI>
<LI><A HREF="#file2">Min-cost max-flow</A></LI>
<LI><A HREF="#file3">Edmonds Max Matching</A></LI>
<LI><A HREF="#file4">Global min-cut</A></LI>
</OL>
<H2>Geometry</H2>

<OL START=5>
<LI><A HREF="#file5">Convex hull</A></LI>
<LI><A HREF="#file6">Miscellaneous geometry</A></LI>
<LI><A HREF="#file7">3D geometry</A></LI>
<LI><A HREF="#file8">Slow Delaunay triangulation</A></LI>
</OL>
<H2>Numerical algorithms</H2>

<OL START=9>
<LI><A HREF="#file9">Number theory (modular, Chinese remainder, linear Diophantine)</A></LI>
<LI><A HREF="#file10">Systems of linear equations, matrix inverse, determinant</A></LI>
<LI><A HREF="#file11">Reduced row echelon form, matrix rank</A></LI>
<LI><A HREF="#file12">Simplex algorithm</A></LI>
<LI><A HREF="#file13">Fast Fourier transform</A></LI>
<LI><A HREF="#file14">BigInt library</A></LI>
</OL>
<H2>Graph algorithms</H2>

<OL START=15>
<LI><A HREF="#file15">Bellman-Ford shortest paths with negative edge weights</A></LI>
<LI><A HREF="#file16">Eulerian path</A></LI>
<LI><A HREF="#file17">Minimum spanning trees</A></LI>
<LI><A HREF="#file18">Centroid decomposition</A></LI>
<LI><A HREF="#file19">Heavy-Light decomposition</A></LI>
</OL>
<H2>Data structures</H2>

<OL START=20>
<LI><A HREF="#file20">Suffix array</A></LI>
<LI><A HREF="#file21">KD-tree</A></LI>
<LI><A HREF="#file22">Splay tree</A></LI>
</OL>
<H2>Miscellaneous</H2>

<OL START=23>
<LI><A HREF="#file23">Miller-Rabin Primality Test</A></LI>
<LI><A HREF="#file24">Pollard-Rho factorization</A></LI>
<LI><A HREF="#file25">Manachers algorithm</A></LI>
<LI><A HREF="#file26">Convex Hull Trick</A></LI>
<LI><A HREF="#file27">Dynamic Programming(DnC)</A></LI>
<LI><A HREF="#file28">Longest increasing subsequence</A></LI>
<LI><A HREF="#file29">Dates</A></LI>
<LI><A HREF="#file30">Knuth-Morris-Pratt</A></LI>
<LI><A HREF="#file31">2-SAT</A></LI>
</OL>
<HR>
<A NAME="file1">
<H1>code/Dinic.cc 1/31</H1>
[<A HREF="#top">top</A>][prev][<A HREF="#file2">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> Dinic {
  <B><FONT COLOR="#228B22">struct</FONT></B> Edge {
    <B><FONT COLOR="#228B22">int</FONT></B> u, v;
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> cap, flow;
    Edge() {}
    Edge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> cap): u(u), v(v), cap(cap), flow(0) {}
  }; 
  <B><FONT COLOR="#228B22">int</FONT></B> N;
  vector&lt;Edge&gt; E;
  vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; g;
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; d, pt;

  Dinic(<B><FONT COLOR="#228B22">int</FONT></B> N): N(N), E(0), g(N), d(N), pt(N) {}

  <B><FONT COLOR="#228B22">void</FONT></B> AddEdge(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> cap) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (u != v) {
      E.emplace_back(Edge(u, v, cap));
      g[u].emplace_back(E.size() - 1);
      E.emplace_back(Edge(v, u, 0));
      g[v].emplace_back(E.size() - 1);
    }
  }

  <B><FONT COLOR="#228B22">bool</FONT></B> BFS(<B><FONT COLOR="#228B22">int</FONT></B> S, <B><FONT COLOR="#228B22">int</FONT></B> T) {
    queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q({S});
    fill(d.begin(), d.end(), N + 1);
    d[S] = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B>(!q.empty()) {
      <B><FONT COLOR="#228B22">int</FONT></B> u = q.front(); q.pop();
      <B><FONT COLOR="#A020F0">if</FONT></B> (u == T) <B><FONT COLOR="#A020F0">break</FONT></B>;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k: g[u]) {
        Edge &amp;e = E[k];
        <B><FONT COLOR="#A020F0">if</FONT></B> (e.flow &lt; e.cap &amp;&amp; d[e.v] &gt; d[e.u] + 1) {
          d[e.v] = d[e.u] + 1;
          q.emplace(e.v);
          }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> d[T] != N + 1;
  }

  <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> DFS(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> T, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> flow = -1) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (u == T || flow == 0) <B><FONT COLOR="#A020F0">return</FONT></B> flow;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> &amp;i = pt[u]; i &lt; g[u].size(); ++i) {
      Edge &amp;e = E[g[u][i]];
      Edge &amp;oe = E[g[u][i]^1];
      <B><FONT COLOR="#A020F0">if</FONT></B> (d[e.v] == d[e.u] + 1) {
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> amt = e.cap - e.flow;
        <B><FONT COLOR="#A020F0">if</FONT></B> (flow != -1 &amp;&amp; amt &gt; flow) amt = flow;
        <B><FONT COLOR="#A020F0">if</FONT></B> (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> pushed = DFS(e.v, T, amt)) {
          e.flow += pushed;
          oe.flow -= pushed;
          <B><FONT COLOR="#A020F0">return</FONT></B> pushed;
        }
      }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }

  <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> MaxFlow(<B><FONT COLOR="#228B22">int</FONT></B> S, <B><FONT COLOR="#228B22">int</FONT></B> T) {
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> total = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (BFS(S, T)) {
      fill(pt.begin(), pt.end(), 0);
      <B><FONT COLOR="#A020F0">while</FONT></B> (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> flow = DFS(S, T))
        total += flow;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> total;
  }
};</PRE>
<HR>
<A NAME="file2">
<H1>code/MinCostMaxFlow.cc 2/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file1">prev</A>][<A HREF="#file3">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Implementation of min cost max flow algorithm using adjacency
</FONT></I><I><FONT COLOR="#B22222">// matrix (Edmonds and Karp 1972).  This implementation keeps track of
</FONT></I><I><FONT COLOR="#B22222">// forward and reverse edges separately (so you can set cap[i][j] !=
</FONT></I><I><FONT COLOR="#B22222">// cap[j][i]).  For a regular max flow, set all edge costs to 0.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time, O(|V|^2) cost per augmentation
</FONT></I><I><FONT COLOR="#B22222">//     max flow:           O(|V|^3) augmentations
</FONT></I><I><FONT COLOR="#B22222">//     min cost max flow:  O(|V|^4 * MAX_EDGE_COST) augmentations
</FONT></I><I><FONT COLOR="#B22222">//     
</FONT></I><I><FONT COLOR="#B22222">// INPUT: 
</FONT></I><I><FONT COLOR="#B22222">//     - graph, constructed using AddEdge()
</FONT></I><I><FONT COLOR="#B22222">//     - source
</FONT></I><I><FONT COLOR="#B22222">//     - sink
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - (maximum flow value, minimum cost value)
</FONT></I><I><FONT COLOR="#B22222">//     - To obtain the actual flow, look at positive values only.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> L;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;L&gt; VL;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VL&gt; VVL;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;PII&gt; VPII;

<B><FONT COLOR="#228B22">const</FONT></B> L INF = numeric_limits&lt;L&gt;::max() / 4;

<B><FONT COLOR="#228B22">struct</FONT></B> MinCostMaxFlow {
  <B><FONT COLOR="#228B22">int</FONT></B> N;
  VVL cap, flow, cost;
  VI found;
  VL dist, pi, width;
  VPII dad;

  MinCostMaxFlow(<B><FONT COLOR="#228B22">int</FONT></B> N) : 
    N(N), cap(N, VL(N)), flow(N, VL(N)), cost(N, VL(N)), 
    found(N), dist(N), pi(N), width(N), dad(N) {}
  
  <B><FONT COLOR="#228B22">void</FONT></B> AddEdge(<B><FONT COLOR="#228B22">int</FONT></B> from, <B><FONT COLOR="#228B22">int</FONT></B> to, L cap, L cost) {
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;cap[from][to] = cap;
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;cost[from][to] = cost;
  }
  
  <B><FONT COLOR="#228B22">void</FONT></B> Relax(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> k, L cap, L cost, <B><FONT COLOR="#228B22">int</FONT></B> dir) {
    L val = dist[s] + pi[s] - pi[k] + cost;
    <B><FONT COLOR="#A020F0">if</FONT></B> (cap &amp;&amp; val &lt; dist[k]) {
      dist[k] = val;
      dad[k] = make_pair(s, dir);
      width[k] = min(cap, width[s]);
    }
  }

  L Dijkstra(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
    fill(found.begin(), found.end(), false);
    fill(dist.begin(), dist.end(), INF);
    fill(width.begin(), width.end(), 0);
    dist[s] = 0;
    width[s] = INF;
    
    <B><FONT COLOR="#A020F0">while</FONT></B> (s != -1) {
      <B><FONT COLOR="#228B22">int</FONT></B> best = -1;
      found[s] = true;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; N; k++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (found[k]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        Relax(s, k, cap[s][k] - flow[s][k], cost[s][k], 1);
        Relax(s, k, flow[k][s], -cost[k][s], -1);
        <B><FONT COLOR="#A020F0">if</FONT></B> (best == -1 || dist[k] &lt; dist[best]) best = k;
      }
      s = best;
    }

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; N; k++)
      pi[k] = min(pi[k] + dist[k], INF);
    <B><FONT COLOR="#A020F0">return</FONT></B> width[t];
  }

  pair&lt;L, L&gt; GetMaxFlow(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
    L totflow = 0, totcost = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (L amt = Dijkstra(s, t)) {
      totflow += amt;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> x = t; x != s; x = dad[x].first) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (dad[x].second == 1) {
          flow[dad[x].first][x] += amt;
          totcost += amt * cost[dad[x].first][x];
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          flow[x][dad[x].first] -= amt;
          totcost -= amt * cost[x][dad[x].first];
        }
      }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(totflow, totcost);
  }
};

<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves UVA problem #10594: Data Flow
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
  <B><FONT COLOR="#228B22">int</FONT></B> N, M;

  <B><FONT COLOR="#A020F0">while</FONT></B> (scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;N, &amp;M) == 2) {
    VVL v(M, VL(3));
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++)
      scanf(<B><FONT COLOR="#BC8F8F">&quot;%Ld%Ld%Ld&quot;</FONT></B>, &amp;v[i][0], &amp;v[i][1], &amp;v[i][2]);
    L D, K;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%Ld%Ld&quot;</FONT></B>, &amp;D, &amp;K);

    MinCostMaxFlow mcmf(N+1);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; i++) {
      mcmf.AddEdge(<B><FONT COLOR="#228B22">int</FONT></B>(v[i][0]), <B><FONT COLOR="#228B22">int</FONT></B>(v[i][1]), K, v[i][2]);
      mcmf.AddEdge(<B><FONT COLOR="#228B22">int</FONT></B>(v[i][1]), <B><FONT COLOR="#228B22">int</FONT></B>(v[i][0]), K, v[i][2]);
    }
    mcmf.AddEdge(0, 1, D, 0);
    
    pair&lt;L, L&gt; res = mcmf.GetMaxFlow(0, N);

    <B><FONT COLOR="#A020F0">if</FONT></B> (res.first == D) {
      printf(<B><FONT COLOR="#BC8F8F">&quot;%Ld\n&quot;</FONT></B>, res.second);
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      printf(<B><FONT COLOR="#BC8F8F">&quot;Impossible.\n&quot;</FONT></B>);
    }
  }
  
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file3">
<H1>code/Edmonds.cc 3/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file2">prev</A>][<A HREF="#file4">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/*
Input:
V-&gt;number of vertices
E-&gt;number of edges
pair of vertices as edges (vertices are 1..V)

Output:
output of edmonds() is the maximum matching
match[i] is matched pair of i (-1 if there isn't a matched pair)
 */</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> M=505;
<B><FONT COLOR="#228B22">struct</FONT></B> struct_edge{<B><FONT COLOR="#228B22">int</FONT></B> v;struct_edge* n;};
<B><FONT COLOR="#228B22">typedef</FONT></B> struct_edge* edge;
struct_edge pool[M*M*2];
edge top=pool,adj[M];
<B><FONT COLOR="#228B22">int</FONT></B> V,E,match[M],qh,qt,q[M],father[M],base[M];
<B><FONT COLOR="#228B22">bool</FONT></B> inq[M],inb[M],ed[M][M];
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">add_edge</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u,<B><FONT COLOR="#228B22">int</FONT></B> v)
{
  top-&gt;v=v,top-&gt;n=adj[u],adj[u]=top++;
  top-&gt;v=u,top-&gt;n=adj[v],adj[v]=top++;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">LCA</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> root,<B><FONT COLOR="#228B22">int</FONT></B> u,<B><FONT COLOR="#228B22">int</FONT></B> v)
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> inp[M];
  memset(inp,0,<B><FONT COLOR="#A020F0">sizeof</FONT></B>(inp));
  <B><FONT COLOR="#A020F0">while</FONT></B>(1)
    {
      inp[u=base[u]]=true;
      <B><FONT COLOR="#A020F0">if</FONT></B> (u==root) <B><FONT COLOR="#A020F0">break</FONT></B>;
      u=father[match[u]];
    }
  <B><FONT COLOR="#A020F0">while</FONT></B>(1)
    {
      <B><FONT COLOR="#A020F0">if</FONT></B> (inp[v=base[v]]) <B><FONT COLOR="#A020F0">return</FONT></B> v;
      <B><FONT COLOR="#A020F0">else</FONT></B> v=father[match[v]];
    }
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">mark_blossom</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> lca,<B><FONT COLOR="#228B22">int</FONT></B> u)
{
  <B><FONT COLOR="#A020F0">while</FONT></B> (base[u]!=lca)
    {
      <B><FONT COLOR="#228B22">int</FONT></B> v=match[u];
      inb[base[u]]=inb[base[v]]=true;
      u=father[v];
      <B><FONT COLOR="#A020F0">if</FONT></B> (base[u]!=lca) father[u]=v;
    }
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">blossom_contraction</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> s,<B><FONT COLOR="#228B22">int</FONT></B> u,<B><FONT COLOR="#228B22">int</FONT></B> v)
{
  <B><FONT COLOR="#228B22">int</FONT></B> lca=LCA(s,u,v);
  memset(inb,0,<B><FONT COLOR="#A020F0">sizeof</FONT></B>(inb));
  mark_blossom(lca,u);
  mark_blossom(lca,v);
  <B><FONT COLOR="#A020F0">if</FONT></B> (base[u]!=lca)
    father[u]=v;
  <B><FONT COLOR="#A020F0">if</FONT></B> (base[v]!=lca)
    father[v]=u;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> u=0;u&lt;V;u++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (inb[base[u]])
      {
  base[u]=lca;
  <B><FONT COLOR="#A020F0">if</FONT></B> (!inq[u])
    inq[q[++qt]=u]=true;
      }
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">find_augmenting_path</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> s)
{
  memset(inq,0,<B><FONT COLOR="#A020F0">sizeof</FONT></B>(inq));
  memset(father,-1,<B><FONT COLOR="#A020F0">sizeof</FONT></B>(father));
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;V;i++) base[i]=i;
  inq[q[qh=qt=0]=s]=true;
  <B><FONT COLOR="#A020F0">while</FONT></B> (qh&lt;=qt)
    {
      <B><FONT COLOR="#228B22">int</FONT></B> u=q[qh++];
      <B><FONT COLOR="#A020F0">for</FONT></B> (edge e=adj[u];e;e=e-&gt;n)
        {
    <B><FONT COLOR="#228B22">int</FONT></B> v=e-&gt;v;
    <B><FONT COLOR="#A020F0">if</FONT></B> (base[u]!=base[v]&amp;&amp;match[u]!=v)
      <B><FONT COLOR="#A020F0">if</FONT></B> ((v==s)||(match[v]!=-1 &amp;&amp; father[match[v]]!=-1))
        blossom_contraction(s,u,v);
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (father[v]==-1)
        {
    father[v]=u;
    <B><FONT COLOR="#A020F0">if</FONT></B> (match[v]==-1)
      <B><FONT COLOR="#A020F0">return</FONT></B> v;
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!inq[match[v]])
      inq[q[++qt]=match[v]]=true;
        }
        }
    }
  <B><FONT COLOR="#A020F0">return</FONT></B> -1;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">augment_path</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> s,<B><FONT COLOR="#228B22">int</FONT></B> t)
{
  <B><FONT COLOR="#228B22">int</FONT></B> u=t,v,w;
  <B><FONT COLOR="#A020F0">while</FONT></B> (u!=-1)
    {
      v=father[u];
      w=match[v];
      match[v]=u;
      match[u]=v;
      u=w;
    }
  <B><FONT COLOR="#A020F0">return</FONT></B> t!=-1;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">edmonds</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> matchc=0;
  memset(match,-1,<B><FONT COLOR="#A020F0">sizeof</FONT></B>(match));
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> u=0;u&lt;V;u++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (match[u]==-1)
      matchc+=augment_path(u,find_augmenting_path(u));
  <B><FONT COLOR="#A020F0">return</FONT></B> matchc;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> u,v;
  cin&gt;&gt;V&gt;&gt;E;
  <B><FONT COLOR="#A020F0">while</FONT></B>(E--)
    {
      cin&gt;&gt;u&gt;&gt;v;
      <B><FONT COLOR="#A020F0">if</FONT></B> (!ed[u-1][v-1])
  {
    add_edge(u-1,v-1);
    ed[u-1][v-1]=ed[v-1][u-1]=true;
  }
    }
  cout&lt;&lt;edmonds()&lt;&lt;endl;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;V;i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (i&lt;match[i])
      cout&lt;&lt;i+1&lt;&lt;<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>&lt;&lt;match[i]+1&lt;&lt;endl;
}</PRE>
<HR>
<A NAME="file4">
<H1>code/MinCut.cc 4/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file3">prev</A>][<A HREF="#file5">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Adjacency matrix implementation of Stoer-Wagner min cut algorithm.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time:
</FONT></I><I><FONT COLOR="#B22222">//     O(|V|^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: 
</FONT></I><I><FONT COLOR="#B22222">//     - graph, constructed using AddEdge()
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:
</FONT></I><I><FONT COLOR="#B22222">//     - (min cut value, nodes in half of min cut)
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> INF = 1000000000;

pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, VI&gt; GetMinCut(VVI &amp;weights) {
  <B><FONT COLOR="#228B22">int</FONT></B> N = weights.size();
  VI used(N), cut, best_cut;
  <B><FONT COLOR="#228B22">int</FONT></B> best_weight = -1;
  
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> phase = N-1; phase &gt;= 0; phase--) {
    VI w = weights[0];
    VI added = used;
    <B><FONT COLOR="#228B22">int</FONT></B> prev, last = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; phase; i++) {
      prev = last;
      last = -1;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt; N; j++)
	<B><FONT COLOR="#A020F0">if</FONT></B> (!added[j] &amp;&amp; (last == -1 || w[j] &gt; w[last])) last = j;
      <B><FONT COLOR="#A020F0">if</FONT></B> (i == phase-1) {
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++) weights[prev][j] += weights[last][j];
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++) weights[j][prev] = weights[prev][j];
	used[last] = true;
	cut.push_back(last);
	<B><FONT COLOR="#A020F0">if</FONT></B> (best_weight == -1 || w[last] &lt; best_weight) {
	  best_cut = cut;
	  best_weight = w[last];
	}
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; N; j++)
	  w[j] += weights[last][j];
	added[last] = true;
      }
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(best_weight, best_cut);
}

<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves UVA problem #10989: Bomb, Divide and Conquer
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
  <B><FONT COLOR="#228B22">int</FONT></B> N;
  cin &gt;&gt; N;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) {
    <B><FONT COLOR="#228B22">int</FONT></B> n, m;
    cin &gt;&gt; n &gt;&gt; m;
    VVI weights(n, VI(n));
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++) {
      <B><FONT COLOR="#228B22">int</FONT></B> a, b, c;
      cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
      weights[a-1][b-1] = weights[b-1][a-1] = c;
    }
    pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, VI&gt; res = GetMinCut(weights);
    cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Case #&quot;</FONT></B> &lt;&lt; i+1 &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B> &lt;&lt; res.first &lt;&lt; endl;
  }
}
<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file5">
<H1>code/ConvexHull.cc 5/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file4">prev</A>][<A HREF="#file6">next</A>]
<PRE>
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt; PT;
<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dist</FONT></B>(PT a, PT b){
  <B><FONT COLOR="#A020F0">return</FONT></B> sqrt(pow(a.first-b.first,2)+pow(a.second-b.second,2));
}

<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#0000FF">cross</FONT></B>(PT o, PT a, PT b){
  PT OA = {a.first-o.first,a.second-o.second};
  PT OB = {b.first-o.first,b.second-o.second};
  <B><FONT COLOR="#A020F0">return</FONT></B> OA.first*OB.second - OA.second*OB.first;
}
vector&lt;PT&gt; convexhull(){
  vector&lt;PT&gt; hull;
  sort(a,a+n,[](PT i, PT j){
    <B><FONT COLOR="#A020F0">if</FONT></B>(i.second!=j.second)
      <B><FONT COLOR="#A020F0">return</FONT></B> i.second &lt; j.second;
    <B><FONT COLOR="#A020F0">return</FONT></B> i.first &lt; j.first;
  });
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i){
    <B><FONT COLOR="#A020F0">while</FONT></B>(hull.size()&gt;1 &amp;&amp; cross(hull[hull.size()-2],hull.back(),a[i])&lt;=0)
      hull.pop_back();
    hull.push_back(a[i]);
  }
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=n-1, siz = hull.size();i--;){
    <B><FONT COLOR="#A020F0">while</FONT></B>(hull.size()&gt;siz &amp;&amp; cross(hull[hull.size()-2],hull.back(),a[i])&lt;=0)
      hull.pop_back();
    hull.push_back(a[i]);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> hull;
}</PRE>
<HR>
<A NAME="file6">
<H1>code/Geometry.cc 6/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file5">prev</A>][<A HREF="#file7">next</A>]
<PRE>
<B><FONT COLOR="#228B22">double</FONT></B> INF = 1e100,EPS = 1e-12;

<B><FONT COLOR="#228B22">struct</FONT></B> PT { 
  <B><FONT COLOR="#228B22">double</FONT></B> x, y; 
  PT() {}
  PT(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y) : x(x), y(y) {}
  PT(<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p) : x(p.x), y(p.y)    {}
  PT <B><FONT COLOR="#A020F0">operator</FONT></B> + (<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p)  <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x+p.x, y+p.y); }
  PT <B><FONT COLOR="#A020F0">operator</FONT></B> - (<B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p)  <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x-p.x, y-p.y); }
  PT <B><FONT COLOR="#A020F0">operator</FONT></B> * (<B><FONT COLOR="#228B22">double</FONT></B> c)     <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x*c,   y*c  ); }
  PT <B><FONT COLOR="#A020F0">operator</FONT></B> / (<B><FONT COLOR="#228B22">double</FONT></B> c)     <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> PT(x/c,   y/c  ); }
};

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dot</FONT></B>(PT p, PT q)     { <B><FONT COLOR="#A020F0">return</FONT></B> p.x*q.x+p.y*q.y; }
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dist2</FONT></B>(PT p, PT q)   { <B><FONT COLOR="#A020F0">return</FONT></B> dot(p-q,p-q); }
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">cross</FONT></B>(PT p, PT q)   { <B><FONT COLOR="#A020F0">return</FONT></B> p.x*q.y-p.y*q.x; }
ostream &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(ostream &amp;os, <B><FONT COLOR="#228B22">const</FONT></B> PT &amp;p) {
  os &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;(&quot;</FONT></B> &lt;&lt; p.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;,&quot;</FONT></B> &lt;&lt; p.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>; 
}

<I><FONT COLOR="#B22222">// rotate a point CCW or CW around the origin
</FONT></I>PT <B><FONT COLOR="#0000FF">RotateCCW90</FONT></B>(PT p)   { <B><FONT COLOR="#A020F0">return</FONT></B> PT(-p.y,p.x); }
PT <B><FONT COLOR="#0000FF">RotateCW90</FONT></B>(PT p)    { <B><FONT COLOR="#A020F0">return</FONT></B> PT(p.y,-p.x); }
PT <B><FONT COLOR="#0000FF">RotateCCW</FONT></B>(PT p, <B><FONT COLOR="#228B22">double</FONT></B> t) { 
  <B><FONT COLOR="#A020F0">return</FONT></B> PT(p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)); 
}

<I><FONT COLOR="#B22222">// project point c onto line through a and b
</FONT></I><I><FONT COLOR="#B22222">// assuming a != b
</FONT></I>PT <B><FONT COLOR="#0000FF">ProjectPointLine</FONT></B>(PT a, PT b, PT c) {
  <B><FONT COLOR="#A020F0">return</FONT></B> a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);
}

<I><FONT COLOR="#B22222">// project point c onto line segment through a and b
</FONT></I>PT <B><FONT COLOR="#0000FF">ProjectPointSegment</FONT></B>(PT a, PT b, PT c) {
  <B><FONT COLOR="#228B22">double</FONT></B> r = dot(b-a,b-a);
  <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(r) &lt; EPS) <B><FONT COLOR="#A020F0">return</FONT></B> a;
  r = dot(c-a, b-a)/r;
  <B><FONT COLOR="#A020F0">if</FONT></B> (r &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> a;
  <B><FONT COLOR="#A020F0">if</FONT></B> (r &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> b;
  <B><FONT COLOR="#A020F0">return</FONT></B> a + (b-a)*r;
}

<I><FONT COLOR="#B22222">// compute distance from c to segment between a and b
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointSegment</FONT></B>(PT a, PT b, PT c) {
  <B><FONT COLOR="#A020F0">return</FONT></B> sqrt(dist2(c, ProjectPointSegment(a, b, c)));
}

<I><FONT COLOR="#B22222">// compute distance between point (x,y,z) and plane ax+by+cz=d
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DistancePointPlane</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> x, <B><FONT COLOR="#228B22">double</FONT></B> y, <B><FONT COLOR="#228B22">double</FONT></B> z,
                          <B><FONT COLOR="#228B22">double</FONT></B> a, <B><FONT COLOR="#228B22">double</FONT></B> b, <B><FONT COLOR="#228B22">double</FONT></B> c, <B><FONT COLOR="#228B22">double</FONT></B> d)
{
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(a*x+b*y+c*z-d)/sqrt(a*a+b*b+c*c);
}

<I><FONT COLOR="#B22222">// determine if lines from a to b and c to d are parallel or collinear
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">LinesParallel</FONT></B>(PT a, PT b, PT c, PT d) { 
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(cross(b-a, c-d)) &lt; EPS; 
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">LinesCollinear</FONT></B>(PT a, PT b, PT c, PT d) { 
  <B><FONT COLOR="#A020F0">return</FONT></B> LinesParallel(a, b, c, d)
      &amp;&amp; fabs(cross(a-b, a-c)) &lt; EPS
      &amp;&amp; fabs(cross(c-d, c-a)) &lt; EPS; 
}

<I><FONT COLOR="#B22222">// determine if line segment from a to b intersects with 
</FONT></I><I><FONT COLOR="#B22222">// line segment from c to d
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">SegmentsIntersect</FONT></B>(PT a, PT b, PT c, PT d) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (LinesCollinear(a, b, c, d)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (dist2(a, c) &lt; EPS || dist2(a, d) &lt; EPS ||
      dist2(b, c) &lt; EPS || dist2(b, d) &lt; EPS) <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">if</FONT></B> (dot(c-a, c-b) &gt; 0 &amp;&amp; dot(d-a, d-b) &gt; 0 &amp;&amp; dot(c-b, d-b) &gt; 0)
      <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (cross(d-a, b-a) * cross(c-a, b-a) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
  <B><FONT COLOR="#A020F0">if</FONT></B> (cross(a-c, d-c) * cross(b-c, d-c) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
  <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">// compute intersection of line passing through a and b
</FONT></I><I><FONT COLOR="#B22222">// with line passing through c and d, assuming that unique
</FONT></I><I><FONT COLOR="#B22222">// intersection exists; for segment intersection, check if
</FONT></I><I><FONT COLOR="#B22222">// segments intersect first
</FONT></I>PT <B><FONT COLOR="#0000FF">ComputeLineIntersection</FONT></B>(PT a, PT b, PT c, PT d) {
  b=b-a; d=c-d; c=c-a;
  assert(dot(b, b) &gt; EPS &amp;&amp; dot(d, d) &gt; EPS);
  <B><FONT COLOR="#A020F0">return</FONT></B> a + b*cross(c, d)/cross(b, d);
}

<I><FONT COLOR="#B22222">// compute center of circle given three points
</FONT></I>PT <B><FONT COLOR="#0000FF">ComputeCircleCenter</FONT></B>(PT a, PT b, PT c) {
  b=(a+b)/2;
  c=(a+c)/2;
  <B><FONT COLOR="#A020F0">return</FONT></B> ComputeLineIntersection(b, b+RotateCW90(a-b), c, c+RotateCW90(a-c));
}

<I><FONT COLOR="#B22222">// determine if point is in a possibly non-convex polygon (by William
</FONT></I><I><FONT COLOR="#B22222">// Randolph Franklin); returns 1 for strictly interior points, 0 for
</FONT></I><I><FONT COLOR="#B22222">// strictly exterior points, and 0 or 1 for the remaining points.
</FONT></I><I><FONT COLOR="#B22222">// Note that it is possible to convert this into an *exact* test using
</FONT></I><I><FONT COLOR="#B22222">// integer arithmetic by taking care of the division appropriately
</FONT></I><I><FONT COLOR="#B22222">// (making sure to deal with signs properly) and then by writing exact
</FONT></I><I><FONT COLOR="#B22222">// tests for checking point on polygon boundary
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">PointInPolygon</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p, PT q) {
  <B><FONT COLOR="#228B22">bool</FONT></B> c = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++){
    <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1)%p.size();
    <B><FONT COLOR="#A020F0">if</FONT></B> ((p[i].y &lt;= q.y &amp;&amp; q.y &lt; p[j].y || 
      p[j].y &lt;= q.y &amp;&amp; q.y &lt; p[i].y) &amp;&amp;
      q.x &lt; p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))
      c = !c;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> c;
}

<I><FONT COLOR="#B22222">// determine if point is on the boundary of a polygon
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">PointOnPolygon</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p, PT q) {
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (dist2(ProjectPointSegment(p[i], p[(i+1)%p.size()], q), q) &lt; EPS)
      <B><FONT COLOR="#A020F0">return</FONT></B> true;
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<I><FONT COLOR="#B22222">// compute intersection of line through points a and b with
</FONT></I><I><FONT COLOR="#B22222">// circle centered at c with radius r &gt; 0
</FONT></I>vector&lt;PT&gt; CircleLineIntersection(PT a, PT b, PT c, <B><FONT COLOR="#228B22">double</FONT></B> r) {
  vector&lt;PT&gt; ret;
  b = b-a;
  a = a-c;
  <B><FONT COLOR="#228B22">double</FONT></B> A = dot(b, b);
  <B><FONT COLOR="#228B22">double</FONT></B> B = dot(a, b);
  <B><FONT COLOR="#228B22">double</FONT></B> C = dot(a, a) - r*r;
  <B><FONT COLOR="#228B22">double</FONT></B> D = B*B - A*C;
  <B><FONT COLOR="#A020F0">if</FONT></B> (D &lt; -EPS) <B><FONT COLOR="#A020F0">return</FONT></B> ret;
  ret.push_back(c+a+b*(-B+sqrt(D+EPS))/A);
  <B><FONT COLOR="#A020F0">if</FONT></B> (D &gt; EPS)
    ret.push_back(c+a+b*(-B-sqrt(D))/A);
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// compute intersection of circle centered at a with radius r
</FONT></I><I><FONT COLOR="#B22222">// with circle centered at b with radius R
</FONT></I>vector&lt;PT&gt; CircleCircleIntersection(PT a, PT b, <B><FONT COLOR="#228B22">double</FONT></B> r, <B><FONT COLOR="#228B22">double</FONT></B> R) {
  vector&lt;PT&gt; ret;
  <B><FONT COLOR="#228B22">double</FONT></B> d = sqrt(dist2(a, b));
  <B><FONT COLOR="#A020F0">if</FONT></B> (d &gt; r+R || d+min(r, R) &lt; max(r, R)) <B><FONT COLOR="#A020F0">return</FONT></B> ret;
  <B><FONT COLOR="#228B22">double</FONT></B> x = (d*d-R*R+r*r)/(2*d);
  <B><FONT COLOR="#228B22">double</FONT></B> y = sqrt(r*r-x*x);
  PT v = (b-a)/d;
  ret.push_back(a+v*x + RotateCCW90(v)*y);
  <B><FONT COLOR="#A020F0">if</FONT></B> (y &gt; 0)
    ret.push_back(a+v*x - RotateCCW90(v)*y);
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// This code computes the area or centroid of a (possibly nonconvex)
</FONT></I><I><FONT COLOR="#B22222">// polygon, assuming that the coordinates are listed in a clockwise or
</FONT></I><I><FONT COLOR="#B22222">// counterclockwise fashion.  Note that the centroid is often known as
</FONT></I><I><FONT COLOR="#B22222">// the &quot;center of gravity&quot; or &quot;center of mass&quot;.
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ComputeSignedArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
  <B><FONT COLOR="#228B22">double</FONT></B> area = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
    <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % p.size();
    area += p[i].x*p[j].y - p[j].x*p[i].y;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> area / 2.0;
}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ComputeArea</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(ComputeSignedArea(p));
}

PT <B><FONT COLOR="#0000FF">ComputeCentroid</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
  PT c(0,0);
  <B><FONT COLOR="#228B22">double</FONT></B> scale = 6.0 * ComputeSignedArea(p);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++){
    <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % p.size();
    c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> c / scale;
}

<I><FONT COLOR="#B22222">// tests whether or not a given polygon (in CW or CCW order) is simple
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">IsSimple</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;PT&gt; &amp;p) {
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.size(); i++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = i+1; k &lt; p.size(); k++) {
      <B><FONT COLOR="#228B22">int</FONT></B> j = (i+1) % p.size();
      <B><FONT COLOR="#228B22">int</FONT></B> l = (k+1) % p.size();
      <B><FONT COLOR="#A020F0">if</FONT></B> (i == l || j == k) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      <B><FONT COLOR="#A020F0">if</FONT></B> (SegmentsIntersect(p[i], p[j], p[k], p[l])) 
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> true;
}</PRE>
<HR>
<A NAME="file7">
<H1>code/Geom3D.java 7/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file6">prev</A>][<A HREF="#file8">next</A>]
<PRE>
<B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">class</FONT></B> Geom3D {
  <I><FONT COLOR="#B22222">// distance from point (x, y, z) to plane aX + bY + cZ + d = 0
</FONT></I>  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> ptPlaneDist(<B><FONT COLOR="#A020F0">double</FONT></B> x, <B><FONT COLOR="#A020F0">double</FONT></B> y, <B><FONT COLOR="#A020F0">double</FONT></B> z,
      <B><FONT COLOR="#A020F0">double</FONT></B> a, <B><FONT COLOR="#A020F0">double</FONT></B> b, <B><FONT COLOR="#A020F0">double</FONT></B> c, <B><FONT COLOR="#A020F0">double</FONT></B> d) {
    <B><FONT COLOR="#A020F0">return</FONT></B> Math.abs(a*x + b*y + c*z + d) / Math.sqrt(a*a + b*b + c*c);
  }
  
  <I><FONT COLOR="#B22222">// distance between parallel planes aX + bY + cZ + d1 = 0 and
</FONT></I>  <I><FONT COLOR="#B22222">// aX + bY + cZ + d2 = 0
</FONT></I>  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> planePlaneDist(<B><FONT COLOR="#A020F0">double</FONT></B> a, <B><FONT COLOR="#A020F0">double</FONT></B> b, <B><FONT COLOR="#A020F0">double</FONT></B> c,
      <B><FONT COLOR="#A020F0">double</FONT></B> d1, <B><FONT COLOR="#A020F0">double</FONT></B> d2) {
    <B><FONT COLOR="#A020F0">return</FONT></B> Math.abs(d1 - d2) / Math.sqrt(a*a + b*b + c*c);
  }
  
  <I><FONT COLOR="#B22222">// distance from point (px, py, pz) to line (x1, y1, z1)-(x2, y2, z2)
</FONT></I>  <I><FONT COLOR="#B22222">// (or ray, or segment; in the case of the ray, the endpoint is the
</FONT></I>  <I><FONT COLOR="#B22222">// first point)
</FONT></I>  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> <B><FONT COLOR="#A020F0">int</FONT></B> LINE = 0;
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> <B><FONT COLOR="#A020F0">int</FONT></B> SEGMENT = 1;
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> <B><FONT COLOR="#A020F0">int</FONT></B> RAY = 2;
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> ptLineDistSq(<B><FONT COLOR="#A020F0">double</FONT></B> x1, <B><FONT COLOR="#A020F0">double</FONT></B> y1, <B><FONT COLOR="#A020F0">double</FONT></B> z1,
      <B><FONT COLOR="#A020F0">double</FONT></B> x2, <B><FONT COLOR="#A020F0">double</FONT></B> y2, <B><FONT COLOR="#A020F0">double</FONT></B> z2, <B><FONT COLOR="#A020F0">double</FONT></B> px, <B><FONT COLOR="#A020F0">double</FONT></B> py, <B><FONT COLOR="#A020F0">double</FONT></B> pz,
      <B><FONT COLOR="#A020F0">int</FONT></B> type) {
    <B><FONT COLOR="#A020F0">double</FONT></B> pd2 = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2);
    
    <B><FONT COLOR="#A020F0">double</FONT></B> x, y, z;
    <B><FONT COLOR="#A020F0">if</FONT></B> (pd2 == 0) {
      x = x1;
      y = y1;
      z = z1;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      <B><FONT COLOR="#A020F0">double</FONT></B> u = ((px-x1)*(x2-x1) + (py-y1)*(y2-y1) + (pz-z1)*(z2-z1)) / pd2;
      x = x1 + u * (x2 - x1);
      y = y1 + u * (y2 - y1);
      z = z1 + u * (z2 - z1);
      <B><FONT COLOR="#A020F0">if</FONT></B> (type != LINE &amp;&amp; u &lt; 0) {
        x = x1;
        y = y1;
        z = z1;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (type == SEGMENT &amp;&amp; u &gt; 1.0) {
        x = x2;
        y = y2;
        z = z2;
      }
    }
    
    <B><FONT COLOR="#A020F0">return</FONT></B> (x-px)*(x-px) + (y-py)*(y-py) + (z-pz)*(z-pz);
  }
  
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">double</FONT></B> ptLineDist(<B><FONT COLOR="#A020F0">double</FONT></B> x1, <B><FONT COLOR="#A020F0">double</FONT></B> y1, <B><FONT COLOR="#A020F0">double</FONT></B> z1,
      <B><FONT COLOR="#A020F0">double</FONT></B> x2, <B><FONT COLOR="#A020F0">double</FONT></B> y2, <B><FONT COLOR="#A020F0">double</FONT></B> z2, <B><FONT COLOR="#A020F0">double</FONT></B> px, <B><FONT COLOR="#A020F0">double</FONT></B> py, <B><FONT COLOR="#A020F0">double</FONT></B> pz,
      <B><FONT COLOR="#A020F0">int</FONT></B> type) {
    <B><FONT COLOR="#A020F0">return</FONT></B> Math.sqrt(ptLineDistSq(x1, y1, z1, x2, y2, z2, px, py, pz, type));
  }
}
</PRE>
<HR>
<A NAME="file8">
<H1>code/Delaunay.cc 8/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file7">prev</A>][<A HREF="#file9">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Slow but simple Delaunay triangulation. Does not handle
</FONT></I><I><FONT COLOR="#B22222">// degenerate cases (from O'Rourke, Computational Geometry in C)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^4)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    x[] = x-coordinates
</FONT></I><I><FONT COLOR="#B22222">//           y[] = y-coordinates
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   triples = a vector containing m triples of indices
</FONT></I><I><FONT COLOR="#B22222">//                     corresponding to triangle vertices
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include&lt;vector&gt;</FONT></B>
using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;

<B><FONT COLOR="#228B22">struct</FONT></B> triple {
    <B><FONT COLOR="#228B22">int</FONT></B> i, j, k;
    triple() {}
    triple(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j, <B><FONT COLOR="#228B22">int</FONT></B> k) : i(i), j(j), k(k) {}
};

vector&lt;triple&gt; delaunayTriangulation(vector&lt;T&gt;&amp; x, vector&lt;T&gt;&amp; y) {
	<B><FONT COLOR="#228B22">int</FONT></B> n = x.size();
	vector&lt;T&gt; z(n);
	vector&lt;triple&gt; ret;

	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
	    z[i] = x[i] * x[i] + y[i] * y[i];

	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n-2; i++) {
	    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i+1; j &lt; n; j++) {
		<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = i+1; k &lt; n; k++) {
		    <B><FONT COLOR="#A020F0">if</FONT></B> (j == k) <B><FONT COLOR="#A020F0">continue</FONT></B>;
		    <B><FONT COLOR="#228B22">double</FONT></B> xn = (y[j]-y[i])*(z[k]-z[i]) - (y[k]-y[i])*(z[j]-z[i]);
		    <B><FONT COLOR="#228B22">double</FONT></B> yn = (x[k]-x[i])*(z[j]-z[i]) - (x[j]-x[i])*(z[k]-z[i]);
		    <B><FONT COLOR="#228B22">double</FONT></B> zn = (x[j]-x[i])*(y[k]-y[i]) - (x[k]-x[i])*(y[j]-y[i]);
		    <B><FONT COLOR="#228B22">bool</FONT></B> flag = zn &lt; 0;
		    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> m = 0; flag &amp;&amp; m &lt; n; m++)
			flag = flag &amp;&amp; ((x[m]-x[i])*xn + 
					(y[m]-y[i])*yn + 
					(z[m]-z[i])*zn &lt;= 0);
		    <B><FONT COLOR="#A020F0">if</FONT></B> (flag) ret.push_back(triple(i, j, k));
		}
	    }
	}
	<B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>()
{
    T xs[]={0, 0, 1, 0.9};
    T ys[]={0, 1, 0, 0.9};
    vector&lt;T&gt; x(&amp;xs[0], &amp;xs[4]), y(&amp;ys[0], &amp;ys[4]);
    vector&lt;triple&gt; tri = delaunayTriangulation(x, y);
    
    <I><FONT COLOR="#B22222">//expected: 0 1 3
</FONT></I>    <I><FONT COLOR="#B22222">//          0 3 2
</FONT></I>    
    <B><FONT COLOR="#228B22">int</FONT></B> i;
    <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; tri.size(); i++)
        printf(<B><FONT COLOR="#BC8F8F">&quot;%d %d %d\n&quot;</FONT></B>, tri[i].i, tri[i].j, tri[i].k);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file9">
<H1>code/Euclid.cc 9/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file8">prev</A>][<A HREF="#file10">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// All algorithms described here work on nonnegative integers.
</FONT></I>
<I><FONT COLOR="#B22222">// return a % b (positive value)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">mod</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
	<B><FONT COLOR="#A020F0">return</FONT></B> ((a%b) + b) % b;
}

<I><FONT COLOR="#B22222">// computes lcm(a,b)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">lcm</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
	<B><FONT COLOR="#A020F0">return</FONT></B> a / __gcd(a, b)*b;
}

<I><FONT COLOR="#B22222">// (a^b) mod m via successive squaring
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">powermod</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> m){
	<B><FONT COLOR="#A020F0">return</FONT></B> b?powermod(a*a%m,b/2,m)*(b%2?a:1)%m:1;
}

<I><FONT COLOR="#B22222">// returns g = gcd(a, b); finds x, y such that d = ax + by
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">extended_euclid</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> &amp;x, <B><FONT COLOR="#228B22">int</FONT></B> &amp;y) {
	<B><FONT COLOR="#228B22">int</FONT></B> xx = y = 0;
	<B><FONT COLOR="#228B22">int</FONT></B> yy = x = 1;
	<B><FONT COLOR="#A020F0">while</FONT></B> (b) {
		<B><FONT COLOR="#228B22">int</FONT></B> q = a / b;
		<B><FONT COLOR="#228B22">int</FONT></B> t = b; b = a%b; a = t;
		t = xx; xx = x - q*xx; x = t;
		t = yy; yy = y - q*yy; y = t;
	}
	<B><FONT COLOR="#A020F0">return</FONT></B> a;
}

<I><FONT COLOR="#B22222">// finds all solutions to ax = b (mod n)
</FONT></I>VI <B><FONT COLOR="#0000FF">modular_linear_equation_solver</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> n) {
	<B><FONT COLOR="#228B22">int</FONT></B> x, y;
	VI ret;
	<B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(a, n, x, y);
	<B><FONT COLOR="#A020F0">if</FONT></B> (!(b%g)) {
		x = mod(x*(b / g), n);
		<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; g; i++)
			ret.push_back(mod(x + i*(n / g), n));
	}
	<B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// computes b such that ab = 1 (mod n), returns -1 on failure
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">mod_inverse</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> n) {
	<B><FONT COLOR="#228B22">int</FONT></B> x, y;
	<B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(a, n, x, y);
	<B><FONT COLOR="#A020F0">if</FONT></B> (g &gt; 1) <B><FONT COLOR="#A020F0">return</FONT></B> -1;
	<B><FONT COLOR="#A020F0">return</FONT></B> mod(x, n);
}

<I><FONT COLOR="#B22222">// Chinese remainder theorem (special case): find z such that
</FONT></I><I><FONT COLOR="#B22222">// z % m1 = r1, z % m2 = r2.  Here, z is unique modulo M = lcm(m1, m2).
</FONT></I><I><FONT COLOR="#B22222">// Return (z, M).  On failure, M = -1.
</FONT></I>PII <B><FONT COLOR="#0000FF">chinese_remainder_theorem</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> m1, <B><FONT COLOR="#228B22">int</FONT></B> r1, <B><FONT COLOR="#228B22">int</FONT></B> m2, <B><FONT COLOR="#228B22">int</FONT></B> r2) {
	<B><FONT COLOR="#228B22">int</FONT></B> s, t;
	<B><FONT COLOR="#228B22">int</FONT></B> g = extended_euclid(m1, m2, s, t);
	<B><FONT COLOR="#A020F0">if</FONT></B> (r1%g != r2%g) <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(0, -1);
	<B><FONT COLOR="#A020F0">return</FONT></B> make_pair(mod(s*r2*m1 + t*r1*m2, m1*m2) / g, m1*m2 / g);
}

<I><FONT COLOR="#B22222">// Chinese remainder theorem: find z such that
</FONT></I><I><FONT COLOR="#B22222">// z % m[i] = r[i] for all i.  Note that the solution is
</FONT></I><I><FONT COLOR="#B22222">// unique modulo M = lcm_i (m[i]).  Return (z, M). On 
</FONT></I><I><FONT COLOR="#B22222">// failure, M = -1. Note that we do not require the a[i]'s
</FONT></I><I><FONT COLOR="#B22222">// to be relatively prime.
</FONT></I>PII <B><FONT COLOR="#0000FF">chinese_remainder_theorem</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> VI &amp;m, <B><FONT COLOR="#228B22">const</FONT></B> VI &amp;r) {
	PII ret = make_pair(r[0], m[0]);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; m.size(); i++) {
		ret = chinese_remainder_theorem(ret.second, ret.first, m[i], r[i]);
		<B><FONT COLOR="#A020F0">if</FONT></B> (ret.second == -1) <B><FONT COLOR="#A020F0">break</FONT></B>;
	}
	<B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// computes x and y such that ax + by = c
</FONT></I><I><FONT COLOR="#B22222">// returns whether the solution exists
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">linear_diophantine</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> c, <B><FONT COLOR="#228B22">int</FONT></B> &amp;x, <B><FONT COLOR="#228B22">int</FONT></B> &amp;y) {
	<B><FONT COLOR="#A020F0">if</FONT></B> (!a &amp;&amp; !b) {
		<B><FONT COLOR="#A020F0">if</FONT></B> (c) <B><FONT COLOR="#A020F0">return</FONT></B> false;
		x = 0; y = 0;
		<B><FONT COLOR="#A020F0">return</FONT></B> true;
	}
	<B><FONT COLOR="#A020F0">if</FONT></B> (!a) {
		<B><FONT COLOR="#A020F0">if</FONT></B> (c % b) <B><FONT COLOR="#A020F0">return</FONT></B> false;
		x = 0; y = c / b;
		<B><FONT COLOR="#A020F0">return</FONT></B> true;
	}
	<B><FONT COLOR="#A020F0">if</FONT></B> (!b) {
		<B><FONT COLOR="#A020F0">if</FONT></B> (c % a) <B><FONT COLOR="#A020F0">return</FONT></B> false;
		x = c / a; y = 0;
		<B><FONT COLOR="#A020F0">return</FONT></B> true;
	}
	<B><FONT COLOR="#228B22">int</FONT></B> g = __gcd(a, b);
	<B><FONT COLOR="#A020F0">if</FONT></B> (c % g) <B><FONT COLOR="#A020F0">return</FONT></B> false;
	x = c / g * mod_inverse(a / g, b / g);
	y = (c - a*x) / b;
	<B><FONT COLOR="#A020F0">return</FONT></B> true;
}</PRE>
<HR>
<A NAME="file10">
<H1>code/GaussJordan.cc 10/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file9">prev</A>][<A HREF="#file11">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Gauss-Jordan elimination with full pivoting.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Uses:
</FONT></I><I><FONT COLOR="#B22222">//   (1) solving systems of linear equations (AX=B)
</FONT></I><I><FONT COLOR="#B22222">//   (2) inverting matrices (AX=I)
</FONT></I><I><FONT COLOR="#B22222">//   (3) computing determinants of square matrices
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    a[][] = an nxn matrix
</FONT></I><I><FONT COLOR="#B22222">//           b[][] = an nxm matrix
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   X      = an nxm matrix (stored in b[][])
</FONT></I><I><FONT COLOR="#B22222">//           A^{-1} = an nxn matrix (stored in a[][])
</FONT></I><I><FONT COLOR="#B22222">//           returns determinant of a[][]
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> EPS = 1e-10;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;

T GaussJordan(VVT &amp;a, VVT &amp;b) {
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = a.size();
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = b[0].size();
  VI irow(n), icol(n), ipiv(n);
  T det = 1;

  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
    <B><FONT COLOR="#228B22">int</FONT></B> pj = -1, pk = -1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) <B><FONT COLOR="#A020F0">if</FONT></B> (!ipiv[j])
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) <B><FONT COLOR="#A020F0">if</FONT></B> (!ipiv[k])
	<B><FONT COLOR="#A020F0">if</FONT></B> (pj == -1 || fabs(a[j][k]) &gt; fabs(a[pj][pk])) { pj = j; pk = k; }
    <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[pj][pk]) &lt; EPS) { cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Matrix is singular.&quot;</FONT></B> &lt;&lt; endl; exit(0); }
    ipiv[pk]++;
    swap(a[pj], a[pk]);
    swap(b[pj], b[pk]);
    <B><FONT COLOR="#A020F0">if</FONT></B> (pj != pk) det *= -1;
    irow[i] = pj;
    icol[i] = pk;

    T c = 1.0 / a[pk][pk];
    det *= a[pk][pk];
    a[pk][pk] = 1.0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; n; p++) a[pk][p] *= c;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; m; p++) b[pk][p] *= c;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = 0; p &lt; n; p++) <B><FONT COLOR="#A020F0">if</FONT></B> (p != pk) {
      c = a[p][pk];
      a[p][pk] = 0;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; n; q++) a[p][q] -= a[pk][q] * c;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> q = 0; q &lt; m; q++) b[p][q] -= b[pk][q] * c;      
    }
  }

  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> p = n-1; p &gt;= 0; p--) <B><FONT COLOR="#A020F0">if</FONT></B> (irow[p] != icol[p]) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) swap(a[k][irow[p]], a[k][icol[p]]);
  }

  <B><FONT COLOR="#A020F0">return</FONT></B> det;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = 4;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = 2;
  <B><FONT COLOR="#228B22">double</FONT></B> A[n][n] = { {1,2,3,4},{1,0,1,0},{5,3,2,4},{6,1,4,6} };
  <B><FONT COLOR="#228B22">double</FONT></B> B[n][m] = { {1,2},{4,3},{5,6},{8,7} };
  VVT a(n), b(n);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
    a[i] = VT(A[i], A[i] + n);
    b[i] = VT(B[i], B[i] + m);
  }
  
  <B><FONT COLOR="#228B22">double</FONT></B> det = GaussJordan(a, b);
  
  <I><FONT COLOR="#B22222">// expected: 60  
</FONT></I>  cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Determinant: &quot;</FONT></B> &lt;&lt; det &lt;&lt; endl;

  <I><FONT COLOR="#B22222">// expected: -0.233333 0.166667 0.133333 0.0666667
</FONT></I>  <I><FONT COLOR="#B22222">//           0.166667 0.166667 0.333333 -0.333333
</FONT></I>  <I><FONT COLOR="#B22222">//           0.233333 0.833333 -0.133333 -0.0666667
</FONT></I>  <I><FONT COLOR="#B22222">//           0.05 -0.75 -0.1 0.2
</FONT></I>  cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Inverse: &quot;</FONT></B> &lt;&lt; endl;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
      cout &lt;&lt; a[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
    cout &lt;&lt; endl;
  }
  
  <I><FONT COLOR="#B22222">// expected: 1.63333 1.3
</FONT></I>  <I><FONT COLOR="#B22222">//           -0.166667 0.5
</FONT></I>  <I><FONT COLOR="#B22222">//           2.36667 1.7
</FONT></I>  <I><FONT COLOR="#B22222">//           -1.85 -1.35
</FONT></I>  cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Solution: &quot;</FONT></B> &lt;&lt; endl;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++)
      cout &lt;&lt; b[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
    cout &lt;&lt; endl;
  }
}
</PRE>
<HR>
<A NAME="file11">
<H1>code/ReducedRowEchelonForm.cc 11/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file10">prev</A>][<A HREF="#file12">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Reduced row echelon form via Gauss-Jordan elimination 
</FONT></I><I><FONT COLOR="#B22222">// with partial pivoting.  This can be used for computing
</FONT></I><I><FONT COLOR="#B22222">// the rank of a matrix.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n^3)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:    a[][] = an nxm matrix
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:   rref[][] = an nxm matrix (stored in a[][])
</FONT></I><I><FONT COLOR="#B22222">//           returns rank of a[][]
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> EPSILON = 1e-10;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">rref</FONT></B>(VVT &amp;a) {
  <B><FONT COLOR="#228B22">int</FONT></B> n = a.size();
  <B><FONT COLOR="#228B22">int</FONT></B> m = a[0].size();
  <B><FONT COLOR="#228B22">int</FONT></B> r = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> c = 0; c &lt; m &amp;&amp; r &lt; n; c++) {
    <B><FONT COLOR="#228B22">int</FONT></B> j = r;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = r + 1; i &lt; n; i++)
      <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[i][c]) &gt; fabs(a[j][c])) j = i;
    <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(a[j][c]) &lt; EPSILON) <B><FONT COLOR="#A020F0">continue</FONT></B>;
    swap(a[j], a[r]);

    T s = 1.0 / a[r][c];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++) a[r][j] *= s;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (i != r) {
      T t = a[i][c];
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++) a[i][j] -= t * a[r][j];
    }
    r++;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> r;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = 5, m = 4;
  <B><FONT COLOR="#228B22">double</FONT></B> A[n][m] = {
    {16,  2,  3, 13},
    { 5, 11, 10,  8},
    { 9,  7,  6, 12},
    { 4, 14, 15,  1},
    {13, 21, 21, 13}};
  VVT a(n);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
    a[i] = VT(A[i], A[i] + m);

  <B><FONT COLOR="#228B22">int</FONT></B> rank = rref(a);

  <I><FONT COLOR="#B22222">// expected: 3
</FONT></I>  cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Rank: &quot;</FONT></B> &lt;&lt; rank &lt;&lt; endl;

  <I><FONT COLOR="#B22222">// expected: 1 0 0 1 
</FONT></I>  <I><FONT COLOR="#B22222">//           0 1 0 3 
</FONT></I>  <I><FONT COLOR="#B22222">//           0 0 1 -3 
</FONT></I>  <I><FONT COLOR="#B22222">//           0 0 0 3.10862e-15
</FONT></I>  <I><FONT COLOR="#B22222">//           0 0 0 2.22045e-15
</FONT></I>  cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;rref: &quot;</FONT></B> &lt;&lt; endl;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 5; i++) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; 4; j++)
      cout &lt;&lt; a[i][j] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
    cout &lt;&lt; endl;
  }
}
</PRE>
<HR>
<A NAME="file12">
<H1>code/Simplex.cc 12/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file11">prev</A>][<A HREF="#file13">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Two-phase simplex algorithm for solving linear programs of the form
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//     maximize     c^T x
</FONT></I><I><FONT COLOR="#B22222">//     subject to   Ax &lt;= b
</FONT></I><I><FONT COLOR="#B22222">//                  x &gt;= 0
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT: A -- an m x n matrix
</FONT></I><I><FONT COLOR="#B22222">//        b -- an m-dimensional vector
</FONT></I><I><FONT COLOR="#B22222">//        c -- an n-dimensional vector
</FONT></I><I><FONT COLOR="#B22222">//        x -- a vector where the optimal solution will be stored
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT: value of the optimal solution (infinity if unbounded
</FONT></I><I><FONT COLOR="#B22222">//         above, nan if infeasible)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// To use this code, create an LPSolver object with A, b, and c as
</FONT></I><I><FONT COLOR="#B22222">// arguments.  Then, call Solve(x).
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iomanip&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;limits&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> DOUBLE;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;DOUBLE&gt; VD;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VD&gt; VVD;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;

<B><FONT COLOR="#228B22">const</FONT></B> DOUBLE EPS = 1e-9;

<B><FONT COLOR="#228B22">struct</FONT></B> LPSolver {
  <B><FONT COLOR="#228B22">int</FONT></B> m, n;
  VI B, N;
  VVD D;

  LPSolver(<B><FONT COLOR="#228B22">const</FONT></B> VVD &amp;A, <B><FONT COLOR="#228B22">const</FONT></B> VD &amp;b, <B><FONT COLOR="#228B22">const</FONT></B> VD &amp;c) :
    m(b.size()), n(c.size()), N(n + 1), B(m), D(m + 2, VD(n + 2)) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) D[i][j] = A[i][j];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) { B[i] = n + i; D[i][n] = -1; D[i][n + 1] = b[i]; }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++) { N[j] = j; D[m][j] = -c[j]; }
    N[n] = -1; D[m + 1][n] = 1;
  }

  <B><FONT COLOR="#228B22">void</FONT></B> Pivot(<B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">int</FONT></B> s) {
    <B><FONT COLOR="#228B22">double</FONT></B> inv = 1.0 / D[r][s];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m + 2; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (i != r)
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n + 2; j++) <B><FONT COLOR="#A020F0">if</FONT></B> (j != s)
        D[i][j] -= D[r][j] * D[i][s] * inv;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n + 2; j++) <B><FONT COLOR="#A020F0">if</FONT></B> (j != s) D[r][j] *= inv;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m + 2; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (i != r) D[i][s] *= -inv;
    D[r][s] = inv;
    swap(B[r], N[s]);
  }

  <B><FONT COLOR="#228B22">bool</FONT></B> Simplex(<B><FONT COLOR="#228B22">int</FONT></B> phase) {
    <B><FONT COLOR="#228B22">int</FONT></B> x = phase == 1 ? m + 1 : m;
    <B><FONT COLOR="#A020F0">while</FONT></B> (true) {
      <B><FONT COLOR="#228B22">int</FONT></B> s = -1;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt;= n; j++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (phase == 2 &amp;&amp; N[j] == -1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (s == -1 || D[x][j] &lt; D[x][s] || D[x][j] == D[x][s] &amp;&amp; N[j] &lt; N[s]) s = j;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (D[x][s] &gt; -EPS) <B><FONT COLOR="#A020F0">return</FONT></B> true;
      <B><FONT COLOR="#228B22">int</FONT></B> r = -1;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (D[i][s] &lt; EPS) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (r == -1 || D[i][n + 1] / D[i][s] &lt; D[r][n + 1] / D[r][s] ||
          (D[i][n + 1] / D[i][s]) == (D[r][n + 1] / D[r][s]) &amp;&amp; B[i] &lt; B[r]) r = i;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (r == -1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
      Pivot(r, s);
    }
  }

  DOUBLE Solve(VD &amp;x) {
    <B><FONT COLOR="#228B22">int</FONT></B> r = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; m; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (D[i][n + 1] &lt; D[r][n + 1]) r = i;
    <B><FONT COLOR="#A020F0">if</FONT></B> (D[r][n + 1] &lt; -EPS) {
      Pivot(r, n);
      <B><FONT COLOR="#A020F0">if</FONT></B> (!Simplex(1) || D[m + 1][n + 1] &lt; -EPS) <B><FONT COLOR="#A020F0">return</FONT></B> -numeric_limits&lt;DOUBLE&gt;::infinity();
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (B[i] == -1) {
        <B><FONT COLOR="#228B22">int</FONT></B> s = -1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt;= n; j++)
          <B><FONT COLOR="#A020F0">if</FONT></B> (s == -1 || D[i][j] &lt; D[i][s] || D[i][j] == D[i][s] &amp;&amp; N[j] &lt; N[s]) s = j;
        Pivot(i, s);
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!Simplex(2)) <B><FONT COLOR="#A020F0">return</FONT></B> numeric_limits&lt;DOUBLE&gt;::infinity();
    x = VD(n);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (B[i] &lt; n) x[B[i]] = D[i][n + 1];
    <B><FONT COLOR="#A020F0">return</FONT></B> D[m][n + 1];
  }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {

  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m = 4;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n = 3;
  DOUBLE _A[m][n] = {
    { 6, -1, 0 },
    { -1, -5, 0 },
    { 1, 5, 1 },
    { -1, -5, -1 }
  };
  DOUBLE _b[m] = { 10, -4, 5, -5 };
  DOUBLE _c[n] = { 1, -1, 0 };

  VVD A(m);
  VD b(_b, _b + m);
  VD c(_c, _c + n);
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) A[i] = VD(_A[i], _A[i] + n);

  LPSolver solver(A, b, c);
  VD x;
  DOUBLE value = solver.Solve(x);

  cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;VALUE: &quot;</FONT></B> &lt;&lt; value &lt;&lt; endl; <I><FONT COLOR="#B22222">// VALUE: 1.29032
</FONT></I>  cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;SOLUTION:&quot;</FONT></B>; <I><FONT COLOR="#B22222">// SOLUTION: 1.74194 0.451613 1
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B> (size_t i = 0; i &lt; x.size(); i++) cerr &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; x[i];
  cerr &lt;&lt; endl;
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
</PRE>
<HR>
<A NAME="file13">
<H1>code/FFT.cc 13/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file12">prev</A>][<A HREF="#file14">next</A>]
<PRE>
<B><FONT COLOR="#228B22">auto</FONT></B> FFT = [](vector&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>&gt;a,vector&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>&gt;b){
  <B><FONT COLOR="#228B22">auto</FONT></B> DFT = [](vector&lt;<B><FONT COLOR="#228B22">complex</FONT></B>&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt;&amp;a, <B><FONT COLOR="#228B22">bool</FONT></B> inv){
    <B><FONT COLOR="#228B22">int</FONT></B> L=31-__builtin_clz(a.size()), n=1&lt;&lt;L;
    vector&lt;<B><FONT COLOR="#228B22">complex</FONT></B>&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; A(n);
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> k=0,r,i;k&lt;n;A[r]=a[k++]) 
      <B><FONT COLOR="#A020F0">for</FONT></B>(i=r=0;i&lt;L;(r&lt;&lt;=1)|=(k&gt;&gt;i++)&amp;1);
    <B><FONT COLOR="#228B22">complex</FONT></B>&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>&gt; w,wm,t;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> m=2,j,k;m&lt;=n;m&lt;&lt;=1) 
      <B><FONT COLOR="#A020F0">for</FONT></B>(w={0,2*acos(-1)/m},wm=exp(inv?-w:w),k=0;k&lt;n;k+=m)
        <B><FONT COLOR="#A020F0">for</FONT></B>(j=0,w=1;j&lt;m/2;++j,w*=wm)
          t=w*A[k+j+m/2],A[k+j+m/2]=A[k+j]-t,A[k+j]+=t;
    <B><FONT COLOR="#A020F0">return</FONT></B> A;
  };  
  <B><FONT COLOR="#228B22">int</FONT></B> n=4&lt;&lt;31-__builtin_clz(max(a.size(),b.size()));
  vector&lt;<B><FONT COLOR="#228B22">complex</FONT></B>&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; A(n), B(n), CC(n);
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i) 
    A[i]=i&lt;a.size()?a[i]:0,B[i]=i&lt;b.size()?b[i]:0;
  vector&lt;<B><FONT COLOR="#228B22">complex</FONT></B>&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; AA=DFT(A,0), BB=DFT(B,0);
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;n;++i) CC[i]=AA[i]*BB[i];
  vector&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B>&gt; c;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> i:DFT(CC,1)) <B><FONT COLOR="#A020F0">if</FONT></B>(c.size()&lt;a.size()+b.size()-1) 
    c.push_back(i.real()/n+1e-5);
  <B><FONT COLOR="#A020F0">return</FONT></B> c;
};</PRE>
<HR>
<A NAME="file14">
<H1>code/bignum.cc 14/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file13">prev</A>][<A HREF="#file15">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> bigint {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> base = 1000000000, base_digits = 9;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; a;
    <B><FONT COLOR="#228B22">int</FONT></B> sign;
    bigint() : sign(1) {}
    bigint(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> v) {
        *<B><FONT COLOR="#A020F0">this</FONT></B> = v;
    }
    bigint(<B><FONT COLOR="#228B22">const</FONT></B> string &amp;s) {
        read(s);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) {
        sign = v.sign;
        a = v.a;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>=(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> v) {
        sign = 1;
        <B><FONT COLOR="#A020F0">if</FONT></B> (v &lt; 0) sign = -1, v = -v;
        <B><FONT COLOR="#A020F0">for</FONT></B> (; v &gt; 0; v = v / base)
            a.push_back(v % base);
    }
    bigint <B><FONT COLOR="#A020F0">operator</FONT></B>+(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (sign == v.sign) {
            bigint res = v;

            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0, carry = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) max(a.size(), v.a.size()) || carry; ++i) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (i == (<B><FONT COLOR="#228B22">int</FONT></B>) res.a.size())
                    res.a.push_back(0);
                res.a[i] += carry + (i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) a.size() ? a[i] : 0);
                carry = res.a[i] &gt;= base;
                <B><FONT COLOR="#A020F0">if</FONT></B> (carry)
                    res.a[i] -= base;
            }
            <B><FONT COLOR="#A020F0">return</FONT></B> res;
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B> - (-v);
    }
    bigint <B><FONT COLOR="#A020F0">operator</FONT></B>-(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (sign == v.sign) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (abs() &gt;= v.abs()) {
                bigint res = *<B><FONT COLOR="#A020F0">this</FONT></B>;
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0, carry = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) v.a.size() || carry; ++i) {
                    res.a[i] -= carry + (i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) v.a.size() ? v.a[i] : 0);
                    carry = res.a[i] &lt; 0;
                    <B><FONT COLOR="#A020F0">if</FONT></B> (carry)
                        res.a[i] += base;
                }
                res.trim();
                <B><FONT COLOR="#A020F0">return</FONT></B> res;
            }
            <B><FONT COLOR="#A020F0">return</FONT></B> -(v - *<B><FONT COLOR="#A020F0">this</FONT></B>);
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B> + (-v);
    }
    <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>*=(<B><FONT COLOR="#228B22">int</FONT></B> v) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (v &lt; 0)
            sign = -sign, v = -v;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0, carry = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) a.size() || carry; ++i) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (i == (<B><FONT COLOR="#228B22">int</FONT></B>) a.size())
                a.push_back(0);
            <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> cur = a[i] * (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>) v + carry;
            carry = (<B><FONT COLOR="#228B22">int</FONT></B>) (cur / base);
            a[i] = (<B><FONT COLOR="#228B22">int</FONT></B>) (cur % base);
            <I><FONT COLOR="#B22222">//asm(&quot;divl %%ecx&quot; : &quot;=a&quot;(carry), &quot;=d&quot;(a[i]) : &quot;A&quot;(cur), &quot;c&quot;(base));
</FONT></I>        }
        trim();
    }
    bigint <B><FONT COLOR="#A020F0">operator</FONT></B>*(<B><FONT COLOR="#228B22">int</FONT></B> v) <B><FONT COLOR="#228B22">const</FONT></B> {
        bigint res = *<B><FONT COLOR="#A020F0">this</FONT></B>;
        res *= v;
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
    <B><FONT COLOR="#228B22">friend</FONT></B> pair&lt;bigint, bigint&gt; divmod(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;a1, <B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;b1) {
        <B><FONT COLOR="#228B22">int</FONT></B> norm = a1.base / (b1.a.back() + 1);
        bigint a = a1.abs() * norm;
        bigint b = b1.abs() * norm;
        bigint q, r;
        q.a.resize(a.a.size());
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = a.a.size() - 1; i &gt;= 0; i--) {
            r *= a1.base;
            r += a.a[i];
            <B><FONT COLOR="#228B22">int</FONT></B> s1 = r.a.size() &lt;= b.a.size() ? 0 : r.a[b.a.size()];
            <B><FONT COLOR="#228B22">int</FONT></B> s2 = r.a.size() &lt;= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];
            <B><FONT COLOR="#228B22">int</FONT></B> d = ((<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>) a1.base * s1 + s2) / b.a.back();
            r -= b * d;
            <B><FONT COLOR="#A020F0">while</FONT></B> (r &lt; 0)
                r += b, --d;
            q.a[i] = d;
        }
        q.sign = a1.sign * b1.sign;
        r.sign = a1.sign;
        q.trim();
        r.trim();
        <B><FONT COLOR="#A020F0">return</FONT></B> make_pair(q, r / norm);
    }
    bigint <B><FONT COLOR="#A020F0">operator</FONT></B>/(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> divmod(*<B><FONT COLOR="#A020F0">this</FONT></B>, v).first;
    }
    bigint <B><FONT COLOR="#A020F0">operator</FONT></B>%(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> divmod(*<B><FONT COLOR="#A020F0">this</FONT></B>, v).second;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>/=(<B><FONT COLOR="#228B22">int</FONT></B> v) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (v &lt; 0) sign = -sign, v = -v;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = (<B><FONT COLOR="#228B22">int</FONT></B>) a.size() - 1, rem = 0; i &gt;= 0; --i) {
            <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> cur = a[i] + rem * (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>) base;
            a[i] = (<B><FONT COLOR="#228B22">int</FONT></B>) (cur / v);
            rem = (<B><FONT COLOR="#228B22">int</FONT></B>) (cur % v);
        }
        trim();
    }
    bigint <B><FONT COLOR="#A020F0">operator</FONT></B>/(<B><FONT COLOR="#228B22">int</FONT></B> v) <B><FONT COLOR="#228B22">const</FONT></B> {
        bigint res = *<B><FONT COLOR="#A020F0">this</FONT></B>;
        res /= v;
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
    <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>%(<B><FONT COLOR="#228B22">int</FONT></B> v) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (v &lt; 0)
            v = -v;
        <B><FONT COLOR="#228B22">int</FONT></B> m = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = a.size() - 1; i &gt;= 0; --i)
            m = (a[i] + m * (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>) base) % v;
        <B><FONT COLOR="#A020F0">return</FONT></B> m * sign;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>+=(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) {
        *<B><FONT COLOR="#A020F0">this</FONT></B> = *<B><FONT COLOR="#A020F0">this</FONT></B> + v;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>-=(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) {
        *<B><FONT COLOR="#A020F0">this</FONT></B> = *<B><FONT COLOR="#A020F0">this</FONT></B> - v;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>*=(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) {
        *<B><FONT COLOR="#A020F0">this</FONT></B> = *<B><FONT COLOR="#A020F0">this</FONT></B> * v;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>/=(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) {
        *<B><FONT COLOR="#A020F0">this</FONT></B> = *<B><FONT COLOR="#A020F0">this</FONT></B> / v;
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (sign != v.sign)
            <B><FONT COLOR="#A020F0">return</FONT></B> sign &lt; v.sign;
        <B><FONT COLOR="#A020F0">if</FONT></B> (a.size() != v.a.size())
            <B><FONT COLOR="#A020F0">return</FONT></B> a.size() * sign &lt; v.a.size() * v.sign;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = a.size() - 1; i &gt;= 0; i--)
            <B><FONT COLOR="#A020F0">if</FONT></B> (a[i] != v.a[i])
                <B><FONT COLOR="#A020F0">return</FONT></B> a[i] * sign &lt; v.a[i] * sign;
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> v &lt; *<B><FONT COLOR="#A020F0">this</FONT></B>;
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;=(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> !(v &lt; *<B><FONT COLOR="#A020F0">this</FONT></B>);
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&gt;=(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> !(*<B><FONT COLOR="#A020F0">this</FONT></B> &lt; v);
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> !(*<B><FONT COLOR="#A020F0">this</FONT></B> &lt; v) &amp;&amp; !(v &lt; *<B><FONT COLOR="#A020F0">this</FONT></B>);
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>!=(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> *<B><FONT COLOR="#A020F0">this</FONT></B> &lt; v || v &lt; *<B><FONT COLOR="#A020F0">this</FONT></B>;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> trim() {
        <B><FONT COLOR="#A020F0">while</FONT></B> (!a.empty() &amp;&amp; !a.back())
            a.pop_back();
        <B><FONT COLOR="#A020F0">if</FONT></B> (a.empty())
            sign = 1;
    }
    <B><FONT COLOR="#228B22">bool</FONT></B> isZero() <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> a.empty() || (a.size() == 1 &amp;&amp; !a[0]);
    }
    bigint <B><FONT COLOR="#A020F0">operator</FONT></B>-() <B><FONT COLOR="#228B22">const</FONT></B> {
        bigint res = *<B><FONT COLOR="#A020F0">this</FONT></B>;
        res.sign = -sign;
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
    bigint abs() <B><FONT COLOR="#228B22">const</FONT></B> {
        bigint res = *<B><FONT COLOR="#A020F0">this</FONT></B>;
        res.sign *= res.sign;
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> longValue() <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> res = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = a.size() - 1; i &gt;= 0; i--)
            res = res * base + a[i];
        <B><FONT COLOR="#A020F0">return</FONT></B> res * sign;
    }
    <B><FONT COLOR="#228B22">friend</FONT></B> bigint gcd(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;b) {
        <B><FONT COLOR="#A020F0">return</FONT></B> b.isZero() ? a : gcd(b, a % b);
    }
    <B><FONT COLOR="#228B22">friend</FONT></B> bigint lcm(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;b) {
        <B><FONT COLOR="#A020F0">return</FONT></B> a / gcd(a, b) * b;
    }
    <B><FONT COLOR="#228B22">void</FONT></B> read(<B><FONT COLOR="#228B22">const</FONT></B> string &amp;s) {
        sign = 1;
        a.clear();
        <B><FONT COLOR="#228B22">int</FONT></B> pos = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B> (pos &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) s.size() &amp;&amp; (s[pos] == <B><FONT COLOR="#BC8F8F">'-'</FONT></B> || s[pos] == <B><FONT COLOR="#BC8F8F">'+'</FONT></B>)) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (s[pos] == <B><FONT COLOR="#BC8F8F">'-'</FONT></B>) sign = -sign;
            ++pos;
        }
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = s.size() - 1; i &gt;= pos; i -= base_digits) {
            <B><FONT COLOR="#228B22">int</FONT></B> x = 0;
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = max(pos, i - base_digits + 1); j &lt;= i; j++)
                x = x * 10 + s[j] - <B><FONT COLOR="#BC8F8F">'0'</FONT></B>;
            a.push_back(x);
        }
        trim();
    }
    <B><FONT COLOR="#228B22">friend</FONT></B> istream&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&gt;&gt;(istream &amp;stream, bigint &amp;v) {
        string s;
        stream &gt;&gt; s;
        v.read(s);
        <B><FONT COLOR="#A020F0">return</FONT></B> stream;
    }
    <B><FONT COLOR="#228B22">friend</FONT></B> ostream&amp; <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;&lt;(ostream &amp;stream, <B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (v.sign == -1) stream &lt;&lt; <B><FONT COLOR="#BC8F8F">'-'</FONT></B>;
        stream &lt;&lt; (v.a.empty() ? 0 : v.a.back());
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = (<B><FONT COLOR="#228B22">int</FONT></B>) v.a.size() - 2; i &gt;= 0; --i)
            stream &lt;&lt; setw(v.base_digits) &lt;&lt; setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>) &lt;&lt; v.a[i];
        <B><FONT COLOR="#A020F0">return</FONT></B> stream;
    }
    <B><FONT COLOR="#228B22">static</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; convert_base(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;a, <B><FONT COLOR="#228B22">int</FONT></B> old_digits, <B><FONT COLOR="#228B22">int</FONT></B> new_digits) {
        vector&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt; p(max(old_digits, new_digits) + 1);
        p[0] = 1;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) p.size(); i++)
            p[i] = p[i - 1] * 10;
        vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; res;
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> cur = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> cur_digits = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) a.size(); i++) {
            cur += a[i] * p[cur_digits];
            cur_digits += old_digits;
            <B><FONT COLOR="#A020F0">while</FONT></B> (cur_digits &gt;= new_digits) {
                res.push_back(<B><FONT COLOR="#228B22">int</FONT></B>(cur % p[new_digits]));
                cur /= p[new_digits];
                cur_digits -= new_digits;
            }
        }
        res.push_back((<B><FONT COLOR="#228B22">int</FONT></B>) cur);
        <B><FONT COLOR="#A020F0">while</FONT></B> (!res.empty() &amp;&amp; !res.back())
            res.pop_back();
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
    <B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt; vll;
    <B><FONT COLOR="#228B22">static</FONT></B> vll karatsubaMultiply(<B><FONT COLOR="#228B22">const</FONT></B> vll &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> vll &amp;b) {
        <B><FONT COLOR="#228B22">int</FONT></B> n = a.size();
        vll res(n + n);
        <B><FONT COLOR="#A020F0">if</FONT></B> (n &lt;= 32) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
                    res[i + j] += a[i] * b[j];
            <B><FONT COLOR="#A020F0">return</FONT></B> res;
        }
        <B><FONT COLOR="#228B22">int</FONT></B> k = n &gt;&gt; 1;
        vll a1(a.begin(), a.begin() + k);
        vll a2(a.begin() + k, a.end());
        vll b1(b.begin(), b.begin() + k);
        vll b2(b.begin() + k, b.end());
        vll a1b1 = karatsubaMultiply(a1, b1);
        vll a2b2 = karatsubaMultiply(a2, b2);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; k; i++)
            a2[i] += a1[i];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; k; i++)
            b2[i] += b1[i];
        vll r = karatsubaMultiply(a2, b2);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) a1b1.size(); i++)
            r[i] -= a1b1[i];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) a2b2.size(); i++)
            r[i] -= a2b2[i];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) r.size(); i++)
            res[i + k] += r[i];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) a1b1.size(); i++)
            res[i] += a1b1[i];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) a2b2.size(); i++)
            res[i + n] += a2b2[i];
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
    bigint <B><FONT COLOR="#A020F0">operator</FONT></B>*(<B><FONT COLOR="#228B22">const</FONT></B> bigint &amp;v) <B><FONT COLOR="#228B22">const</FONT></B> {
        vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; a6 = convert_base(<B><FONT COLOR="#A020F0">this</FONT></B>-&gt;a, base_digits, 6);
        vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; b6 = convert_base(v.a, base_digits, 6);
        vll a(a6.begin(), a6.end());
        vll b(b6.begin(), b6.end());
        <B><FONT COLOR="#A020F0">while</FONT></B> (a.size() &lt; b.size())
            a.push_back(0);
        <B><FONT COLOR="#A020F0">while</FONT></B> (b.size() &lt; a.size())
            b.push_back(0);
        <B><FONT COLOR="#A020F0">while</FONT></B> (a.size() &amp; (a.size() - 1))
            a.push_back(0), b.push_back(0);
        vll c = karatsubaMultiply(a, b);
        bigint res;
        res.sign = sign * v.sign;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0, carry = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>) c.size(); i++) {
            <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> cur = c[i] + carry;
            res.a.push_back((<B><FONT COLOR="#228B22">int</FONT></B>) (cur % 1000000));
            carry = (<B><FONT COLOR="#228B22">int</FONT></B>) (cur / 1000000);
        }
        res.a = convert_base(res.a, 6, base_digits);
        res.trim();
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
};</PRE>
<HR>
<A NAME="file15">
<H1>code/BellmanFord.cc 15/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file14">prev</A>][<A HREF="#file16">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Single source shortest paths with negative edge weights.
</FONT></I><I><FONT COLOR="#B22222">// Returns false if a negative weight cycle is detected.
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|V|^3)
</FONT></I><I><FONT COLOR="#B22222">//   INPUT:   start, w[i][j] = cost of edge from i to j
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT:  dist[i] = min weight path from start to i
</FONT></I><I><FONT COLOR="#B22222">//            dad[i] = prevector&lt;int&gt;ous node on the best path from the
</FONT></I><I><FONT COLOR="#B22222">//                      start node   
</FONT></I>vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; dad;
vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; dist;
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">BellmanFord</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> start, vector&lt;vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;&gt; &amp;w){
  <B><FONT COLOR="#228B22">int</FONT></B> n = w.size();
  dad = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(n, -1);
  dist = vector&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt;(n, 1000000000);
  dist[start] = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; j++)
        <B><FONT COLOR="#A020F0">if</FONT></B> (dist[j] &gt; dist[i] + w[i][j]){
          <B><FONT COLOR="#A020F0">if</FONT></B> (k == n-1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
          <B><FONT COLOR="#A020F0">else</FONT></B> dist[j] = dist[i] + w[i][j], dad[j] = i;
        }
  
  <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){}
</PRE>
<HR>
<A NAME="file16">
<H1>code/EulerianPath.cc 16/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file15">prev</A>][<A HREF="#file17">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> Edge;
<B><FONT COLOR="#228B22">typedef</FONT></B> list&lt;Edge&gt;::iterator iter;

<B><FONT COLOR="#228B22">struct</FONT></B> Edge
{
	<B><FONT COLOR="#228B22">int</FONT></B> next_vertex;
	iter reverse_edge;

	Edge(<B><FONT COLOR="#228B22">int</FONT></B> next_vertex)
		:next_vertex(next_vertex)
		{ }
};

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> max_vertices = ;
<B><FONT COLOR="#228B22">int</FONT></B> num_vertices;
list&lt;Edge&gt; adj[max_vertices];		<I><FONT COLOR="#B22222">// adjacency list
</FONT></I>
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; path;

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">find_path</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> v)
{
	<B><FONT COLOR="#A020F0">while</FONT></B>(adj[v].size() &gt; 0)
	{
		<B><FONT COLOR="#228B22">int</FONT></B> vn = adj[v].front().next_vertex;
		adj[vn].erase(adj[v].front().reverse_edge);
		adj[v].pop_front();
		find_path(vn);
	}
	path.push_back(v);
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">add_edge</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b)
{
	adj[a].push_front(Edge(b));
	iter ita = adj[a].begin();
	adj[b].push_front(Edge(a));
	iter itb = adj[b].begin();
	ita-&gt;reverse_edge = itb;
	itb-&gt;reverse_edge = ita;
}
</PRE>
<HR>
<A NAME="file17">
<H1>code/Prim.cc 17/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file16">prev</A>][<A HREF="#file18">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// This function runs Prim's algorithm for constructing minimum
</FONT></I><I><FONT COLOR="#B22222">// weight spanning trees.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(|V|^2)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT:   w[i][j] = cost of edge from i to j
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//            NOTE: Make sure that w[i][j] is nonnegative and
</FONT></I><I><FONT COLOR="#B22222">//            symmetric.  Missing edges should be given -1
</FONT></I><I><FONT COLOR="#B22222">//            weight.
</FONT></I><I><FONT COLOR="#B22222">//            
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT:  edges = list of pair&lt;int,int&gt; in minimum spanning tree
</FONT></I><I><FONT COLOR="#B22222">//            return total weight of tree
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;queue&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cmath&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> T;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;T&gt; VT;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VT&gt; VVT;

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;VI&gt; VVI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;PII&gt; VPII;

T Prim (<B><FONT COLOR="#228B22">const</FONT></B> VVT &amp;w, VPII &amp;edges){
  <B><FONT COLOR="#228B22">int</FONT></B> n = w.size();
  VI found (n);
  VI prev (n, -1);
  VT dist (n, 1000000000);
  <B><FONT COLOR="#228B22">int</FONT></B> here = 0;
  dist[here] = 0;
  
  <B><FONT COLOR="#A020F0">while</FONT></B> (here != -1){
    found[here] = true;
    <B><FONT COLOR="#228B22">int</FONT></B> best = -1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; k++) <B><FONT COLOR="#A020F0">if</FONT></B> (!found[k]){
      <B><FONT COLOR="#A020F0">if</FONT></B> (w[here][k] != -1 &amp;&amp; dist[k] &gt; w[here][k]){
        dist[k] = w[here][k];
        prev[k] = here;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (best == -1 || dist[k] &lt; dist[best]) best = k;
    }
    here = best;    
  }
  
  T tot_weight = 0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) <B><FONT COLOR="#A020F0">if</FONT></B> (prev[i] != -1){
    edges.push_back (make_pair (prev[i], i));
    tot_weight += w[prev[i]][i];
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> tot_weight;  
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
  <B><FONT COLOR="#228B22">int</FONT></B> ww[5][5] = {
    {0, 400, 400, 300, 600},
    {400, 0, 3, -1, 7},
    {400, 3, 0, 2, 0},
    {300, -1, 2, 0, 5},
    {600, 7, 0, 5, 0}
  };
  VVT w(5, VT(5));
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 5; i++)
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; 5; j++)
      w[i][j] = ww[i][j];
    
  <I><FONT COLOR="#B22222">// expected: 305
</FONT></I>  <I><FONT COLOR="#B22222">//           2 1
</FONT></I>  <I><FONT COLOR="#B22222">//           3 2
</FONT></I>  <I><FONT COLOR="#B22222">//           0 3
</FONT></I>  <I><FONT COLOR="#B22222">//           2 4
</FONT></I>  
  VPII edges;
  cout &lt;&lt; Prim (w, edges) &lt;&lt; endl;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; edges.size(); i++)
    cout &lt;&lt; edges[i].first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; edges[i].second &lt;&lt; endl;
}
</PRE>
<HR>
<A NAME="file18">
<H1>code/Centroid.cc 18/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file17">prev</A>][<A HREF="#file19">next</A>]
<PRE>
set&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v[100005];
map&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt; mp[100005];
<B><FONT COLOR="#228B22">int</FONT></B> n,up[100005][17],lvl[100005],par[100005],CNT,siz[100005],tin[100005],tout[100005];
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">dfspre</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> dad=1, <B><FONT COLOR="#228B22">int</FONT></B> depth = 0){
    <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> clk = 0;
    tin[u]=clk++;
    up[u][0] = dad;
    lvl[u] = depth;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;17;++i)
        up[u][i] = up[up[u][i-1]][i-1];
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i:v[u]) <B><FONT COLOR="#A020F0">if</FONT></B>(i!=dad)
        dfspre(i,u,depth+1);
    tout[u]=clk++;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">dfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> dad){
    siz[u] = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i:v[u]) <B><FONT COLOR="#A020F0">if</FONT></B>(i!=dad)
        siz[u] += dfs(i,u);
    <B><FONT COLOR="#A020F0">return</FONT></B> siz[u];
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">centroid</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> dad){
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i:v[u]) <B><FONT COLOR="#A020F0">if</FONT></B>(i!=dad &amp;&amp; siz[i]&gt;CNT)
        <B><FONT COLOR="#A020F0">return</FONT></B> centroid(i,u);
    <B><FONT COLOR="#A020F0">return</FONT></B> u;
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">decompose</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> dad){
    CNT = dfs(u,dad)/2;
    <B><FONT COLOR="#228B22">int</FONT></B> centre = centroid(u,dad);
    par[centre] = dad;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i:v[centre]) <B><FONT COLOR="#A020F0">if</FONT></B>(i!=dad){
        v[i].erase(centre);
        decompose(i,centre);
    }
    v[centre].clear();
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">lca</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v){
    <B><FONT COLOR="#A020F0">if</FONT></B>(lvl[u]&gt;lvl[v]) swap(u,v);
    <B><FONT COLOR="#A020F0">if</FONT></B>(tin[u]&lt;=tin[v] &amp;&amp; tout[v]&lt;=tout[u]) <B><FONT COLOR="#A020F0">return</FONT></B> u;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=17;i--;)
        <B><FONT COLOR="#A020F0">if</FONT></B>(!(tin[up[u][i]]&lt;=tin[v] &amp;&amp; tout[v]&lt;=tout[up[u][i]]))
            u = up[u][i];
    <B><FONT COLOR="#A020F0">return</FONT></B> up[u][0];
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">update</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u){
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> node = u;u;u = par[u])
        ++mp[u][lvl[node]+lvl[u] - 2*lvl[lca(u,node)]];
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">get</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u){
    <B><FONT COLOR="#228B22">int</FONT></B> ans = INT_MAX;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> node = u; u; u = par[u])
        ans = min(ans,lvl[u]+lvl[node]-2*lvl[lca(u,node)]+(*mp[u].begin()).first);
    <B><FONT COLOR="#A020F0">return</FONT></B> ans;
}</PRE>
<HR>
<A NAME="file19">
<H1>code/HLD.cc 19/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file18">prev</A>][<A HREF="#file20">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;
<B><FONT COLOR="#228B22">int</FONT></B> a[100005],sz[100005],lvl[100005];
<B><FONT COLOR="#228B22">int</FONT></B> seg_id[100005],pos_id[100005],parent[100005];
<B><FONT COLOR="#228B22">int</FONT></B> CNT;
<B><FONT COLOR="#228B22">int</FONT></B> e_to_v[100005];
vector&lt;pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; edges(100005);
vector&lt;pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; v[100005];
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; chain[100005];
<B><FONT COLOR="#228B22">template</FONT></B> &lt;typename T&gt;
<B><FONT COLOR="#228B22">class</FONT></B> SegmentTree{
  vector&lt;T&gt; segtree,lazy;
  <B><FONT COLOR="#228B22">public</FONT></B>:
  SegmentTree(<B><FONT COLOR="#228B22">int</FONT></B> size){
    segtree.resize(4*size,0);
    lazy.resize(4*size,0);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j, T x){
    <B><FONT COLOR="#A020F0">if</FONT></B>(lazy[u]){
      segtree[u]+=(b-a+1)*lazy[u];
      <B><FONT COLOR="#A020F0">if</FONT></B>(a!=b)
        lazy[u*2]+=lazy[u],lazy[2*u+1]+=lazy[u];
      lazy[u]=0;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(j&lt;a || i&gt;b || a&gt;b) <B><FONT COLOR="#A020F0">return</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B>(j&gt;=b &amp;&amp; i&lt;=a){
      segtree[u]=x;
      <B><FONT COLOR="#A020F0">if</FONT></B>(a!=b) lazy[u*2]+=x,lazy[2*u+1]+=x;
      <B><FONT COLOR="#A020F0">return</FONT></B>;
    }
    update(u*2,a,(a+b)/2,i,j,x); update(u*2+1,(a+b)/2+1,b,i,j,x);
    segtree[u]=max(segtree[u*2],segtree[u*2+1]);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> i, T x){
    update(1, 0, segtree.size()/4-1, i, i, x);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j, T x){
    update(1, 0, segtree.size()/4-1, i, j, x);
  }
  T query(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j){
    <B><FONT COLOR="#A020F0">if</FONT></B>(j&lt;a || i&gt;b || a&gt;b) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    <B><FONT COLOR="#A020F0">if</FONT></B>(lazy[u]){
      segtree[u]+=(b-a+1)*lazy[u];
      <B><FONT COLOR="#A020F0">if</FONT></B>(a!=b)
        lazy[u*2]+=lazy[u],lazy[2*u+1]+=lazy[u];
      lazy[u]=0;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B>(j&gt;=b &amp;&amp; i&lt;=a) <B><FONT COLOR="#A020F0">return</FONT></B> segtree[u];
    <B><FONT COLOR="#A020F0">return</FONT></B> max(query(u*2,a,(a+b)/2,i,j),query(u*2+1,1+(a+b)/2,b,i,j));
  }
  T query(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j){
    <B><FONT COLOR="#A020F0">return</FONT></B> query(1,0,segtree.size()/4-1,i,j);
  }
};
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">dfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> dad=1, <B><FONT COLOR="#228B22">int</FONT></B> depth=1){
  lvl[u] = depth;
  sz[u] = 1;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> i:v[u]) <B><FONT COLOR="#A020F0">if</FONT></B>(i.first!=dad)
    sz[u] += dfs(i.first,u,depth+1);
  <B><FONT COLOR="#A020F0">return</FONT></B> sz[u];
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">hld</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> dad = 1, <B><FONT COLOR="#228B22">int</FONT></B> chain_no = 0, <B><FONT COLOR="#228B22">int</FONT></B> chain_parent = 0){
  seg_id[u] = chain_no;
  pos_id[u] = chain[chain_no].size();
  parent[u] = chain_parent;
  chain[chain_no].push_back(u);
  <B><FONT COLOR="#228B22">int</FONT></B> max_sz = 0, heavy_child = -1;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> i:v[u]) <B><FONT COLOR="#A020F0">if</FONT></B>(i.first!=dad){
    a[i.first] = i.second;
    <B><FONT COLOR="#A020F0">if</FONT></B>(max_sz &lt; sz[i.first])
      max_sz = sz[i.first], heavy_child = i.first;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B>(heavy_child!=-1)
    hld(heavy_child, u, chain_no, chain_parent);
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> i:v[u]) <B><FONT COLOR="#A020F0">if</FONT></B>(i.first!=dad &amp;&amp; i.first!=heavy_child)
    hld(i.first,u,++CNT, u);
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
  <B><FONT COLOR="#5F9EA0">ios_base</FONT></B>::sync_with_stdio(0);
  cin.tie(0); cout.tie(0);
  <B><FONT COLOR="#228B22">int</FONT></B> T, n, x, y;
  <B><FONT COLOR="#A020F0">for</FONT></B>(cin&gt;&gt;T;T-- &amp;&amp; cin&gt;&gt;n;){
    
    CNT = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;100005;chain[i].clear(), v[i].clear(), i++);

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1,c;i&lt;n;++i){
      cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;
      edges[i] = {x,y};
      v[x].push_back({y,c});
      v[y].push_back({x,c});
    }

    dfs(1);

    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;n;++i){
      <B><FONT COLOR="#228B22">int</FONT></B> u = edges[i].first, v = edges[i].second;
      e_to_v[i] = (lvl[u]&lt;lvl[v]?v:u);
    }

    hld(1);

    vector&lt;SegmentTree&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; ST;
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;=CNT;++i){
      ST.push_back(SegmentTree&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(chain[i].size()));
      <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">auto</FONT></B> u:chain[i])
        ST[i].update(pos_id[u],a[u]);
    }

    <B><FONT COLOR="#A020F0">for</FONT></B>(string type;cin&gt;&gt;type &amp;&amp; type!=<B><FONT COLOR="#BC8F8F">&quot;DONE&quot;</FONT></B>;){
      cin&gt;&gt;x&gt;&gt;y;
      <B><FONT COLOR="#A020F0">if</FONT></B>(type==<B><FONT COLOR="#BC8F8F">&quot;QUERY&quot;</FONT></B>){
        <B><FONT COLOR="#228B22">int</FONT></B> res = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B>(x!=y){
          <B><FONT COLOR="#A020F0">if</FONT></B>(seg_id[x]&gt;seg_id[y]) swap(x,y);
          <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(seg_id[x] == seg_id[y]){
            <B><FONT COLOR="#A020F0">if</FONT></B>(pos_id[x]&gt;pos_id[y]) swap(x,y);
            res = max(res,ST[seg_id[y]].query(pos_id[x]+1,pos_id[y]));
            <B><FONT COLOR="#A020F0">break</FONT></B>;
          }
          res = max(res, ST[seg_id[y]].query(0,pos_id[y]));
          y = parent[y];
        }
        cout&lt;&lt;res&lt;&lt;<B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;
      }
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(type == <B><FONT COLOR="#BC8F8F">&quot;CHANGE&quot;</FONT></B>){
        <B><FONT COLOR="#228B22">int</FONT></B> u = e_to_v[x];
        ST[seg_id[u]].update(pos_id[u],y);
      }
    }
  }
}</PRE>
<HR>
<A NAME="file20">
<H1>code/SuffixArray.cc 20/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file19">prev</A>][<A HREF="#file21">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Suffix array construction in O(L log^2 L) time.  Routine for
</FONT></I><I><FONT COLOR="#B22222">// computing the length of the longest common prefix of any two
</FONT></I><I><FONT COLOR="#B22222">// suffixes in O(log L) time.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// INPUT:   string s
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// OUTPUT:  array suffix[] such that suffix[i] = index (from 0 to L-1)
</FONT></I><I><FONT COLOR="#B22222">//          of substring s[i...L-1] in the list of sorted suffixes.
</FONT></I><I><FONT COLOR="#B22222">//          That is, if we take the inverse of the permutation suffix[],
</FONT></I><I><FONT COLOR="#B22222">//          we get the actual suffix array.
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>

using namespace std;

<B><FONT COLOR="#228B22">struct</FONT></B> SuffixArray {
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> L;
  string s;
  vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; P;
  vector&lt;pair&lt;pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt;,<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; M;

  SuffixArray(<B><FONT COLOR="#228B22">const</FONT></B> string &amp;s) : L(s.length()), s(s), P(1, vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(L, 0)), M(L) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; L; i++) P[0][i] = <B><FONT COLOR="#228B22">int</FONT></B>(s[i]);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> skip = 1, level = 1; skip &lt; L; skip *= 2, level++) {
      P.push_back(vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(L, 0));
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; L; i++) 
	M[i] = make_pair(make_pair(P[level-1][i], i + skip &lt; L ? P[level-1][i + skip] : -1000), i);
      sort(M.begin(), M.end());
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; L; i++) 
	P[level][M[i].second] = (i &gt; 0 &amp;&amp; M[i].first == M[i-1].first) ? P[level][M[i-1].second] : i;
    }    
  }

  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; GetSuffixArray() { <B><FONT COLOR="#A020F0">return</FONT></B> P.back(); }

  <I><FONT COLOR="#B22222">// returns the length of the longest common prefix of s[i...L-1] and s[j...L-1]
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> LongestCommonPrefix(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j) {
    <B><FONT COLOR="#228B22">int</FONT></B> len = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (i == j) <B><FONT COLOR="#A020F0">return</FONT></B> L - i;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = P.size() - 1; k &gt;= 0 &amp;&amp; i &lt; L &amp;&amp; j &lt; L; k--) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (P[k][i] == P[k][j]) {
	i += 1 &lt;&lt; k;
	j += 1 &lt;&lt; k;
	len += 1 &lt;&lt; k;
      }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> len;
  }
};

<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I><I><FONT COLOR="#B22222">// The following code solves UVA problem 11512: GATTACA.
</FONT></I>#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">TESTING</FONT>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">TESTING</FONT>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
  <B><FONT COLOR="#228B22">int</FONT></B> T;
  cin &gt;&gt; T;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> caseno = 0; caseno &lt; T; caseno++) {
    string s;
    cin &gt;&gt; s;
    SuffixArray array(s);
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v = array.GetSuffixArray();
    <B><FONT COLOR="#228B22">int</FONT></B> bestlen = -1, bestpos = -1, bestcount = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; s.length(); i++) {
      <B><FONT COLOR="#228B22">int</FONT></B> len = 0, count = 0;
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i+1; j &lt; s.length(); j++) {
	<B><FONT COLOR="#228B22">int</FONT></B> l = array.LongestCommonPrefix(i, j);
	<B><FONT COLOR="#A020F0">if</FONT></B> (l &gt;= len) {
	  <B><FONT COLOR="#A020F0">if</FONT></B> (l &gt; len) count = 2; <B><FONT COLOR="#A020F0">else</FONT></B> count++;
	  len = l;
	}
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (len &gt; bestlen || len == bestlen &amp;&amp; s.substr(bestpos, bestlen) &gt; s.substr(i, len)) {
	bestlen = len;
	bestcount = count;
	bestpos = i;
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (bestlen == 0) {
      cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;No repetitions found!&quot;</FONT></B> &lt;&lt; endl;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      cout &lt;&lt; s.substr(bestpos, bestlen) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; bestcount &lt;&lt; endl;
    }
  }
}

#<B><FONT COLOR="#5F9EA0">else</FONT></B>
<I><FONT COLOR="#B22222">// END CUT
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
  SuffixArray suffix(<B><FONT COLOR="#BC8F8F">&quot;bobocel&quot;</FONT></B>);
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v = suffix.GetSuffixArray();
  <I><FONT COLOR="#B22222">// Expected output: 0 5 1 6 2 3 4
</FONT></I>  <I><FONT COLOR="#B22222">//                  2
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v.size(); i++) cout &lt;&lt; v[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
  cout &lt;&lt; endl;
  cout &lt;&lt; suffix.LongestCommonPrefix(0, 2) &lt;&lt; endl;
}
<I><FONT COLOR="#B22222">// BEGIN CUT
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
<I><FONT COLOR="#B22222">// END CUT
</FONT></I></PRE>
<HR>
<A NAME="file21">
<H1>code/KDTree.cc 21/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file20">prev</A>][<A HREF="#file22">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// A straightforward, but probably sub-optimal KD-tree implmentation
</FONT></I><I><FONT COLOR="#B22222">// that's probably good enough for most things (current it's a
</FONT></I><I><FONT COLOR="#B22222">// 2D-tree)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//  - constructs from n points in O(n lg^2 n) time
</FONT></I><I><FONT COLOR="#B22222">//  - handles nearest-neighbor query in O(lg n) if points are well
</FONT></I><I><FONT COLOR="#B22222">//    distributed
</FONT></I><I><FONT COLOR="#B22222">//  - worst case for nearest-neighbor may be linear in pathological
</FONT></I><I><FONT COLOR="#B22222">//    case
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Sonny Chan, Stanford University, April 2009
</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;vector&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;limits&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdlib&gt;</FONT></B>
using namespace std;

<I><FONT COLOR="#B22222">// number type for coordinates, and its maximum value
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> ntype;
<B><FONT COLOR="#228B22">const</FONT></B> ntype sentry = numeric_limits&lt;ntype&gt;::max();

<I><FONT COLOR="#B22222">// point structure for 2D-tree, can be extended to 3D
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> point {
    ntype x, y;
    point(ntype xx = 0, ntype yy = 0) : x(xx), y(yy) {}
};

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>==(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b){
    <B><FONT COLOR="#A020F0">return</FONT></B> a.x == b.x &amp;&amp; a.y == b.y;
}

<I><FONT COLOR="#B22222">// sorts points on x-coordinate
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">on_x</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b){
    <B><FONT COLOR="#A020F0">return</FONT></B> a.x &lt; b.x;
}

<I><FONT COLOR="#B22222">// sorts points on y-coordinate
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">on_y</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b){
    <B><FONT COLOR="#A020F0">return</FONT></B> a.y &lt; b.y;
}

<I><FONT COLOR="#B22222">// squared distance between points
</FONT></I>ntype <B><FONT COLOR="#0000FF">pdist2</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b){
    ntype dx = a.x-b.x, dy = a.y-b.y;
    <B><FONT COLOR="#A020F0">return</FONT></B> dx*dx + dy*dy;
}

<I><FONT COLOR="#B22222">// bounding box for a set of points
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> bbox{
    ntype x0, x1, y0, y1;
    
    bbox() : x0(sentry), x1(-sentry), y0(sentry), y1(-sentry) {}
    
    <I><FONT COLOR="#B22222">// computes bounding box from a bunch of points
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> compute(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;point&gt; &amp;v) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v.size(); ++i) {
            x0 = min(x0, v[i].x);   x1 = max(x1, v[i].x);
            y0 = min(y0, v[i].y);   y1 = max(y1, v[i].y);
        }
    }
    
    <I><FONT COLOR="#B22222">// squared distance between a point and this bbox, 0 if inside
</FONT></I>    ntype distance(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;p) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (p.x &lt; x0) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &lt; y0)       <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x0, y0), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &gt; y1)  <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x0, y1), p);
            <B><FONT COLOR="#A020F0">else</FONT></B>                <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x0, p.y), p);
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (p.x &gt; x1) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &lt; y0)       <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x1, y0), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &gt; y1)  <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x1, y1), p);
            <B><FONT COLOR="#A020F0">else</FONT></B>                <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(x1, p.y), p);
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &lt; y0)       <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(p.x, y0), p);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (p.y &gt; y1)  <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(point(p.x, y1), p);
            <B><FONT COLOR="#A020F0">else</FONT></B>                <B><FONT COLOR="#A020F0">return</FONT></B> 0;
        }
    }
};

<I><FONT COLOR="#B22222">// stores a single node of the kd-tree, either internal or leaf
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> kdnode {
    <B><FONT COLOR="#228B22">bool</FONT></B> leaf;      <I><FONT COLOR="#B22222">// true if this is a leaf node (has one point)
</FONT></I>    point pt;       <I><FONT COLOR="#B22222">// the single point of this is a leaf
</FONT></I>    bbox bound;     <I><FONT COLOR="#B22222">// bounding box for set of points in children
</FONT></I>    
    kdnode *first, *second; <I><FONT COLOR="#B22222">// two children of this kd-node
</FONT></I>    
    kdnode() : leaf(false), first(0), second(0) {}
    ~kdnode() { <B><FONT COLOR="#A020F0">if</FONT></B> (first) <B><FONT COLOR="#A020F0">delete</FONT></B> first; <B><FONT COLOR="#A020F0">if</FONT></B> (second) <B><FONT COLOR="#A020F0">delete</FONT></B> second; }
    
    <I><FONT COLOR="#B22222">// intersect a point with this node (returns squared distance)
</FONT></I>    ntype intersect(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;p) {
        <B><FONT COLOR="#A020F0">return</FONT></B> bound.distance(p);
    }
    
    <I><FONT COLOR="#B22222">// recursively builds a kd-tree from a given cloud of points
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> construct(vector&lt;point&gt; &amp;vp){
        <I><FONT COLOR="#B22222">// compute bounding box for points at this node
</FONT></I>        bound.compute(vp);
        
        <I><FONT COLOR="#B22222">// if we're down to one point, then we're a leaf node
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (vp.size() == 1) {
            leaf = true;
            pt = vp[0];
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            <I><FONT COLOR="#B22222">// split on x if the bbox is wider than high (not best heuristic...)
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (bound.x1-bound.x0 &gt;= bound.y1-bound.y0)
                sort(vp.begin(), vp.end(), on_x);
            <I><FONT COLOR="#B22222">// otherwise split on y-coordinate
</FONT></I>            <B><FONT COLOR="#A020F0">else</FONT></B>
                sort(vp.begin(), vp.end(), on_y);
            
            <I><FONT COLOR="#B22222">// divide by taking half the array for each child
</FONT></I>            <I><FONT COLOR="#B22222">// (not best performance if many duplicates in the middle)
</FONT></I>            <B><FONT COLOR="#228B22">int</FONT></B> half = vp.size()/2;
            vector&lt;point&gt; vl(vp.begin(), vp.begin()+half);
            vector&lt;point&gt; vr(vp.begin()+half, vp.end());
            first = <B><FONT COLOR="#A020F0">new</FONT></B> kdnode();   first-&gt;construct(vl);
            second = <B><FONT COLOR="#A020F0">new</FONT></B> kdnode();  second-&gt;construct(vr);            
        }
    }
};

<I><FONT COLOR="#B22222">// simple kd-tree class to hold the tree and handle queries
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> kdtree{
    kdnode *root;
    
    <I><FONT COLOR="#B22222">// constructs a kd-tree from a points (copied here, as it sorts them)
</FONT></I>    kdtree(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;point&gt; &amp;vp) {
        vector&lt;point&gt; v(vp.begin(), vp.end());
        root = <B><FONT COLOR="#A020F0">new</FONT></B> kdnode();
        root-&gt;construct(v);
    }
    ~kdtree() { <B><FONT COLOR="#A020F0">delete</FONT></B> root; }
    
    <I><FONT COLOR="#B22222">// recursive search method returns squared distance to nearest point
</FONT></I>    ntype search(kdnode *node, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;p)
    {
        <B><FONT COLOR="#A020F0">if</FONT></B> (node-&gt;leaf) {
            <I><FONT COLOR="#B22222">// commented special case tells a point not to find itself
</FONT></I><I><FONT COLOR="#B22222">//            if (p == node-&gt;pt) return sentry;
</FONT></I><I><FONT COLOR="#B22222">//            else               
</FONT></I>                <B><FONT COLOR="#A020F0">return</FONT></B> pdist2(p, node-&gt;pt);
        }
        
        ntype bfirst = node-&gt;first-&gt;intersect(p);
        ntype bsecond = node-&gt;second-&gt;intersect(p);
        
        <I><FONT COLOR="#B22222">// choose the side with the closest bounding box to search first
</FONT></I>        <I><FONT COLOR="#B22222">// (note that the other side is also searched if needed)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (bfirst &lt; bsecond) {
            ntype best = search(node-&gt;first, p);
            <B><FONT COLOR="#A020F0">if</FONT></B> (bsecond &lt; best)
                best = min(best, search(node-&gt;second, p));
            <B><FONT COLOR="#A020F0">return</FONT></B> best;
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            ntype best = search(node-&gt;second, p);
            <B><FONT COLOR="#A020F0">if</FONT></B> (bfirst &lt; best)
                best = min(best, search(node-&gt;first, p));
            <B><FONT COLOR="#A020F0">return</FONT></B> best;
        }
    }
    
    <I><FONT COLOR="#B22222">// squared distance to the nearest 
</FONT></I>    ntype nearest(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;p) {
        <B><FONT COLOR="#A020F0">return</FONT></B> search(root, p);
    }
};

<I><FONT COLOR="#B22222">// some basic test code here
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
    <I><FONT COLOR="#B22222">// generate some random points for a kd-tree
</FONT></I>    vector&lt;point&gt; vp;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 100000; ++i) {
        vp.push_back(point(rand()%100000, rand()%100000));
    }
    kdtree tree(vp);
    
    <I><FONT COLOR="#B22222">// query some points
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 10; ++i) {
        point q(rand()%100000, rand()%100000);
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Closest squared distance to (&quot;</FONT></B> &lt;&lt; q.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B> &lt;&lt; q.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;)&quot;</FONT></B>
             &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; is &quot;</FONT></B> &lt;&lt; tree.nearest(q) &lt;&lt; endl;
    }    
}</PRE>
<HR>
<A NAME="file22">
<H1>code/splay.cc 22/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file21">prev</A>][<A HREF="#file23">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;cstdio&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;algorithm&gt;</FONT></B>
using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N_MAX = 130010;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> oo = 0x3f3f3f3f;
<B><FONT COLOR="#228B22">struct</FONT></B> Node
{
  Node *ch[2], *pre;
  <B><FONT COLOR="#228B22">int</FONT></B> val, size;
  <B><FONT COLOR="#228B22">bool</FONT></B> isTurned;
} nodePool[N_MAX], *null, *root;

Node *<B><FONT COLOR="#0000FF">allocNode</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> val)
{
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> freePos = 0;
  Node *x = &amp;nodePool[freePos ++];
  x-&gt;val = val, x-&gt;isTurned = false;
  x-&gt;ch[0] = x-&gt;ch[1] = x-&gt;pre = null;
  x-&gt;size = 1;
  <B><FONT COLOR="#A020F0">return</FONT></B> x;
}

<B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">update</FONT></B>(Node *x)
{
  x-&gt;size = x-&gt;ch[0]-&gt;size + x-&gt;ch[1]-&gt;size + 1;
}

<B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">makeTurned</FONT></B>(Node *x)
{
  <B><FONT COLOR="#A020F0">if</FONT></B>(x == null)
    <B><FONT COLOR="#A020F0">return</FONT></B>;
  swap(x-&gt;ch[0], x-&gt;ch[1]);
  x-&gt;isTurned ^= 1;
}

<B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">pushDown</FONT></B>(Node *x)
{
  <B><FONT COLOR="#A020F0">if</FONT></B>(x-&gt;isTurned)
  {
    makeTurned(x-&gt;ch[0]);
    makeTurned(x-&gt;ch[1]);
    x-&gt;isTurned ^= 1;
  }
}

<B><FONT COLOR="#228B22">inline</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">rotate</FONT></B>(Node *x, <B><FONT COLOR="#228B22">int</FONT></B> c)
{
  Node *y = x-&gt;pre;
  x-&gt;pre = y-&gt;pre;
  <B><FONT COLOR="#A020F0">if</FONT></B>(y-&gt;pre != null)
    y-&gt;pre-&gt;ch[y == y-&gt;pre-&gt;ch[1]] = x;
  y-&gt;ch[!c] = x-&gt;ch[c];
  <B><FONT COLOR="#A020F0">if</FONT></B>(x-&gt;ch[c] != null)
    x-&gt;ch[c]-&gt;pre = y;
  x-&gt;ch[c] = y, y-&gt;pre = x;
  update(y);
  <B><FONT COLOR="#A020F0">if</FONT></B>(y == root)
    root = x;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">splay</FONT></B>(Node *x, Node *p)
{
  <B><FONT COLOR="#A020F0">while</FONT></B>(x-&gt;pre != p)
  {
    <B><FONT COLOR="#A020F0">if</FONT></B>(x-&gt;pre-&gt;pre == p)
      rotate(x, x == x-&gt;pre-&gt;ch[0]);
    <B><FONT COLOR="#A020F0">else</FONT></B>
    {
      Node *y = x-&gt;pre, *z = y-&gt;pre;
      <B><FONT COLOR="#A020F0">if</FONT></B>(y == z-&gt;ch[0])
      {
        <B><FONT COLOR="#A020F0">if</FONT></B>(x == y-&gt;ch[0])
          rotate(y, 1), rotate(x, 1);
        <B><FONT COLOR="#A020F0">else</FONT></B>
          rotate(x, 0), rotate(x, 1);
      }
      <B><FONT COLOR="#A020F0">else</FONT></B>
      {
        <B><FONT COLOR="#A020F0">if</FONT></B>(x == y-&gt;ch[1])
          rotate(y, 0), rotate(x, 0);
        <B><FONT COLOR="#A020F0">else</FONT></B>
          rotate(x, 1), rotate(x, 0);
      }
    }
  }
  update(x);
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">select</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> k, Node *fa)
{
  Node *now = root;
  <B><FONT COLOR="#A020F0">while</FONT></B>(1)
  {
    pushDown(now);
    <B><FONT COLOR="#228B22">int</FONT></B> tmp = now-&gt;ch[0]-&gt;size + 1;
    <B><FONT COLOR="#A020F0">if</FONT></B>(tmp == k)
      <B><FONT COLOR="#A020F0">break</FONT></B>;
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(tmp &lt; k)
      now = now-&gt;ch[1], k -= tmp;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      now = now-&gt;ch[0];
  }
  splay(now, fa);
}

Node *<B><FONT COLOR="#0000FF">makeTree</FONT></B>(Node *p, <B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r)
{
  <B><FONT COLOR="#A020F0">if</FONT></B>(l &gt; r)
    <B><FONT COLOR="#A020F0">return</FONT></B> null;
  <B><FONT COLOR="#228B22">int</FONT></B> mid = (l + r) / 2;
  Node *x = allocNode(mid);
  x-&gt;pre = p;
  x-&gt;ch[0] = makeTree(x, l, mid - 1);
  x-&gt;ch[1] = makeTree(x, mid + 1, r);
  update(x);
  <B><FONT COLOR="#A020F0">return</FONT></B> x;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>()
{
  <B><FONT COLOR="#228B22">int</FONT></B> n, m;
  null = allocNode(0);
  null-&gt;size = 0;
  root = allocNode(0);
  root-&gt;ch[1] = allocNode(oo);
  root-&gt;ch[1]-&gt;pre = root;
  update(root);

  scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;n, &amp;m);
  root-&gt;ch[1]-&gt;ch[0] = makeTree(root-&gt;ch[1], 1, n);
  splay(root-&gt;ch[1]-&gt;ch[0], null);

  <B><FONT COLOR="#A020F0">while</FONT></B>(m --)
  {
    <B><FONT COLOR="#228B22">int</FONT></B> a, b;
    scanf(<B><FONT COLOR="#BC8F8F">&quot;%d%d&quot;</FONT></B>, &amp;a, &amp;b);
    a ++, b ++;
    select(a - 1, null);
    select(b + 1, root);
    makeTurned(root-&gt;ch[1]-&gt;ch[0]);
  }

  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i ++)
  {
    select(i + 1, null);
    printf(<B><FONT COLOR="#BC8F8F">&quot;%d &quot;</FONT></B>, root-&gt;val);
  }
}
</PRE>
<HR>
<A NAME="file23">
<H1>code/MillerRabin.cc 23/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file22">prev</A>][<A HREF="#file24">next</A>]
<PRE>
<I><FONT COLOR="#B22222">//   Error rate: 2^(-TRIAL)
</FONT></I><I><FONT COLOR="#B22222">//   Almost constant time. srand is needed
</FONT></I>
int64_t <B><FONT COLOR="#0000FF">ModMul</FONT></B>(int64_t a, int64_t b, int64_t m){
	int64_t ret=0, c=a;
	<B><FONT COLOR="#A020F0">for</FONT></B>(;b;b&gt;&gt;=1, c=(c+c)%m)
		<B><FONT COLOR="#A020F0">if</FONT></B>(b&amp;1) ret=(ret+c)%m;
	<B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
int64_t <B><FONT COLOR="#0000FF">ModExp</FONT></B>(int64_t a, int64_t n, int64_t m){
	<B><FONT COLOR="#A020F0">return</FONT></B> n?ModMul(ModExp(ModMul(a,a,m),n/2,m),(n%2?a:1),m):1;
}
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">Witness</FONT></B>(int64_t a, int64_t n){
	int64_t u=n-1;
  	<B><FONT COLOR="#228B22">int</FONT></B> t=0;
	<B><FONT COLOR="#A020F0">while</FONT></B>(!(u&amp;1)){u&gt;&gt;=1; t++;}
	int64_t x0=ModExp(a, u, n), x1;
	<B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;=t;i++) {
		x1=ModMul(x0, x0, n);
		<B><FONT COLOR="#A020F0">if</FONT></B>(x1==1&amp;&amp;x0!=1&amp;&amp;x0!=n-1) <B><FONT COLOR="#A020F0">return</FONT></B> true;
		x0=x1;
	}
	<B><FONT COLOR="#A020F0">if</FONT></B>(x0!=1) <B><FONT COLOR="#A020F0">return</FONT></B> true;
	<B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">IsPrimeFast</FONT></B>(int64_t n, <B><FONT COLOR="#228B22">int</FONT></B> TRIAL=15){
  <B><FONT COLOR="#A020F0">if</FONT></B>(n&lt;=2) <B><FONT COLOR="#A020F0">return</FONT></B> (n==2);
  <B><FONT COLOR="#228B22">static</FONT></B> random_device rd;
  <B><FONT COLOR="#228B22">static</FONT></B> mt19937_64 g(rd());
  <B><FONT COLOR="#A020F0">while</FONT></B>(TRIAL--)
    <B><FONT COLOR="#A020F0">if</FONT></B>(Witness(g()/2%(n-2)+1, n)) 
    	<B><FONT COLOR="#A020F0">return</FONT></B> false;
  <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
</PRE>
<HR>
<A NAME="file24">
<H1>code/pollard_rho.cc 24/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file23">prev</A>][<A HREF="#file25">next</A>]
<PRE>
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> llui;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> lli;
<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> float64;

llui <B><FONT COLOR="#0000FF">mul_mod</FONT></B>(llui a, llui b, llui m){
   llui y = (llui)((float64)a*(float64)b/m+(float64)1/2);
   y = y * m;
   llui x = a * b;
   llui r = x - y;
   <B><FONT COLOR="#A020F0">if</FONT></B> ( (lli)r &lt; 0 ){
      r = r + m; y = y - 1;
   }
   <B><FONT COLOR="#A020F0">return</FONT></B> r;
}

llui C,a,b;
llui <B><FONT COLOR="#0000FF">gcd</FONT></B>(){
   llui c;
   <B><FONT COLOR="#A020F0">if</FONT></B>(a&gt;b){
      c = a; a = b; b = c;
   }
   <B><FONT COLOR="#A020F0">while</FONT></B>(1){
      <B><FONT COLOR="#A020F0">if</FONT></B>(a == 1LL) <B><FONT COLOR="#A020F0">return</FONT></B> 1LL;
      <B><FONT COLOR="#A020F0">if</FONT></B>(a == 0 || a == b) <B><FONT COLOR="#A020F0">return</FONT></B> b;
      c = a; a = b%a;
      b = c;
   }
}

llui <B><FONT COLOR="#0000FF">f</FONT></B>(llui a, llui b){
   llui tmp;
   tmp = mul_mod(a,a,b);
   tmp+=C; tmp%=b;
   <B><FONT COLOR="#A020F0">return</FONT></B> tmp;
}

llui <B><FONT COLOR="#0000FF">pollard</FONT></B>(llui n){
   <B><FONT COLOR="#A020F0">if</FONT></B>(!(n&amp;1)) <B><FONT COLOR="#A020F0">return</FONT></B> 2;
   C=0;
   llui iteracoes = 0;
   <B><FONT COLOR="#A020F0">while</FONT></B>(iteracoes &lt;= 1000){
      llui x,y,d;
      x = y = 2; d = 1;
      <B><FONT COLOR="#A020F0">while</FONT></B>(d == 1){
          x = f(x,n);
          y = f(f(y,n),n);
          llui m = (x&gt;y)?(x-y):(y-x);
          a = m; b = n; d = gcd();
      }
      <B><FONT COLOR="#A020F0">if</FONT></B>(d != n)
          <B><FONT COLOR="#A020F0">return</FONT></B> d;
      iteracoes++; C = rand();
   }
   <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

llui <B><FONT COLOR="#0000FF">pot</FONT></B>(llui a, llui b, llui c){
   <B><FONT COLOR="#A020F0">if</FONT></B>(b == 0) <B><FONT COLOR="#A020F0">return</FONT></B> 1;
   <B><FONT COLOR="#A020F0">if</FONT></B>(b == 1) <B><FONT COLOR="#A020F0">return</FONT></B> a%c;
   llui resp = pot(a,b&gt;&gt;1,c);
   resp = mul_mod(resp,resp,c);
   <B><FONT COLOR="#A020F0">if</FONT></B>(b&amp;1)
      resp = mul_mod(resp,a,c);
   <B><FONT COLOR="#A020F0">return</FONT></B> resp;
}

<I><FONT COLOR="#B22222">// Rabin-Miller primality testing algorithm
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">isPrime</FONT></B>(llui n){
   llui d = n-1;
   llui s = 0;
   <B><FONT COLOR="#A020F0">if</FONT></B>(n &lt;=3 || n == 5) <B><FONT COLOR="#A020F0">return</FONT></B> true;
   <B><FONT COLOR="#A020F0">if</FONT></B>(!(n&amp;1)) <B><FONT COLOR="#A020F0">return</FONT></B> false;
   <B><FONT COLOR="#A020F0">while</FONT></B>(!(d&amp;1)){ s++; d&gt;&gt;=1; }
   <B><FONT COLOR="#A020F0">for</FONT></B>(llui i = 0;i&lt;32;i++){
      llui a = rand();
      a &lt;&lt;=32;
      a+=rand();
      a%=(n-3); a+=2;
      llui x = pot(a,d,n);
      <B><FONT COLOR="#A020F0">if</FONT></B>(x == 1 || x == n-1) <B><FONT COLOR="#A020F0">continue</FONT></B>;
      <B><FONT COLOR="#A020F0">for</FONT></B>(llui j = 1;j&lt;= s-1;j++){
         x = mul_mod(x,x,n);
         <B><FONT COLOR="#A020F0">if</FONT></B>(x == 1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
         <B><FONT COLOR="#A020F0">if</FONT></B>(x == n-1)<B><FONT COLOR="#A020F0">break</FONT></B>;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B>(x != n-1) <B><FONT COLOR="#A020F0">return</FONT></B> false;
   }
   <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
map&lt;llui,<B><FONT COLOR="#228B22">int</FONT></B>&gt; factors;
<I><FONT COLOR="#B22222">// Precondition: factors is an empty map, n is a positive integer
</FONT></I><I><FONT COLOR="#B22222">// Postcondition: factors[p] is the exponent of p in prime factorization of n
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">fact</FONT></B>(llui n){
   <B><FONT COLOR="#A020F0">if</FONT></B>(!isPrime(n)){
      llui fac = pollard(n);
      fact(n/fac); fact(fac);
   }<B><FONT COLOR="#A020F0">else</FONT></B>{
      map&lt;llui,<B><FONT COLOR="#228B22">int</FONT></B>&gt;::iterator it;
      it = factors.find(n);
      <B><FONT COLOR="#A020F0">if</FONT></B>(it != factors.end()){
         (*it).second++;
      }<B><FONT COLOR="#A020F0">else</FONT></B>{
         factors[n] = 1;
      }
   }
}</PRE>
<HR>
<A NAME="file25">
<H1>code/manacher.cpp 25/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file24">prev</A>][<A HREF="#file26">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Maximal palindrome lengths centered around each
</FONT></I><I><FONT COLOR="#B22222">// position in a string (including positions between characters) and returns
</FONT></I><I><FONT COLOR="#B22222">// them in left-to-right order of centres. Linear time.
</FONT></I><I><FONT COLOR="#B22222">// Ex: &quot;opposes&quot; -&gt; [0, 1, 0, 1, 4, 1, 0, 1, 0, 1, 0, 3, 0, 1, 0]
</FONT></I>vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; fastLongestPalindromes(string str) {
    <B><FONT COLOR="#228B22">int</FONT></B> i=0,j,d,s,e,lLen,palLen=0;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; res;
    <B><FONT COLOR="#A020F0">while</FONT></B> (i &lt; str.length()) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; palLen &amp;&amp; str[i-palLen-1] == str[i]) {
            palLen += 2; i++; <B><FONT COLOR="#A020F0">continue</FONT></B>;
        }
        res.push_back(palLen);
        s = res.size()-2;
        e = s-palLen;
        <B><FONT COLOR="#228B22">bool</FONT></B> b = true;
        <B><FONT COLOR="#A020F0">for</FONT></B> (j=s; j&gt;e; j--) {
            d = j-e-1;
            <B><FONT COLOR="#A020F0">if</FONT></B> (res[j] == d) { palLen = d; b = false; <B><FONT COLOR="#A020F0">break</FONT></B>; }
            res.push_back(min(d, res[j]));
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (b) { palLen = 1; i++; }
    }
    res.push_back(palLen);
    lLen = res.size();
    s = lLen-2;
    e = s-(2*str.length()+1-lLen);
    <B><FONT COLOR="#A020F0">for</FONT></B> (i=s; i&gt;e; i--) { d = i-e-1; res.push_back(min(d, res[i])); }
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}</PRE>
<HR>
<A NAME="file26">
<H1>code/CHT.cc 26/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file25">prev</A>][<A HREF="#file27">next</A>]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> Line {
	<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> m, b;
	mutable function&lt;<B><FONT COLOR="#228B22">const</FONT></B> Line*()&gt; succ;
	<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> Line&amp; rhs) <B><FONT COLOR="#228B22">const</FONT></B>{
		<B><FONT COLOR="#A020F0">if</FONT></B> (rhs.b != -(1ll&lt;&lt;62)) <B><FONT COLOR="#A020F0">return</FONT></B> m &gt; rhs.m; <I><FONT COLOR="#B22222">// &lt; for max
</FONT></I>		<B><FONT COLOR="#228B22">const</FONT></B> Line* s = succ();
		<B><FONT COLOR="#A020F0">if</FONT></B> (!s) <B><FONT COLOR="#A020F0">return</FONT></B> 0;
		<B><FONT COLOR="#A020F0">return</FONT></B> b-s-&gt;b &gt; (s-&gt;m -m)*rhs.m; <I><FONT COLOR="#B22222">// &lt; for max
</FONT></I>	}
};
<B><FONT COLOR="#228B22">struct</FONT></B> HullDynamic : <B><FONT COLOR="#228B22">public</FONT></B> multiset&lt;Line&gt; {
	<B><FONT COLOR="#228B22">bool</FONT></B> bad(iterator y) {
		<B><FONT COLOR="#228B22">auto</FONT></B> z = next(y);
		<B><FONT COLOR="#A020F0">if</FONT></B>(y==begin()){
			<B><FONT COLOR="#A020F0">if</FONT></B>(z==end())<B><FONT COLOR="#A020F0">return</FONT></B> 0;
			<B><FONT COLOR="#A020F0">return</FONT></B> y-&gt;m == z-&gt;m &amp;&amp; y-&gt;b &gt;= z-&gt;b; <I><FONT COLOR="#B22222">// &lt;= for max
</FONT></I>		}
		<B><FONT COLOR="#228B22">auto</FONT></B> x = prev(y);
		<B><FONT COLOR="#A020F0">if</FONT></B> (z == end()) <B><FONT COLOR="#A020F0">return</FONT></B> y-&gt;m == x-&gt;m &amp;&amp; y-&gt;b &gt;= x-&gt;b;  <I><FONT COLOR="#B22222">// &lt;= for max
</FONT></I>		<B><FONT COLOR="#A020F0">return</FONT></B> (x-&gt;b - y-&gt;b)*1.0*(z-&gt;m - y-&gt;m) &gt;= (y-&gt;b - z-&gt;b)*1.0*(y-&gt;m - x-&gt;m); 
	}
	<B><FONT COLOR="#228B22">void</FONT></B> insert_line(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> m, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> b) {
		<B><FONT COLOR="#228B22">auto</FONT></B> y = insert({ m, b });
		y-&gt;succ = [=] { <B><FONT COLOR="#A020F0">return</FONT></B> next(y) == end() ? 0 : &amp;*next(y); };
		<B><FONT COLOR="#A020F0">if</FONT></B> (bad(y)) { erase(y); <B><FONT COLOR="#A020F0">return</FONT></B>; }
		<B><FONT COLOR="#A020F0">while</FONT></B> (next(y) != end() &amp;&amp; bad(next(y))) erase(next(y));
		<B><FONT COLOR="#A020F0">while</FONT></B> (y != begin() &amp;&amp; bad(prev(y))) erase(prev(y));
	}
	<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> eval(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> x) {
		<B><FONT COLOR="#228B22">auto</FONT></B> l = *lower_bound((Line){x,-(1ll&lt;&lt;62)});
		<B><FONT COLOR="#A020F0">return</FONT></B> l.m * x + l.b;
	}
};</PRE>
<HR>
<A NAME="file27">
<H1>code/DnCDP.cpp 27/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file26">prev</A>][<A HREF="#file28">next</A>]
<PRE>
<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> dp[21][100005];
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">cost</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y);
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">computeDP</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> idx,<B><FONT COLOR="#228B22">int</FONT></B> jleft,<B><FONT COLOR="#228B22">int</FONT></B> jright,<B><FONT COLOR="#228B22">int</FONT></B> kleft,<B><FONT COLOR="#228B22">int</FONT></B> kright){
	<B><FONT COLOR="#A020F0">if</FONT></B>(jleft&gt;jright) <B><FONT COLOR="#A020F0">return</FONT></B>;
	<B><FONT COLOR="#228B22">int</FONT></B> jmid=(jleft+jright)/2;
	<B><FONT COLOR="#228B22">int</FONT></B> bestk=jmid;
	<B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> k=kleft;k&lt;=min(kright,jmid);++k){
		cost(k,jmid);
		<B><FONT COLOR="#A020F0">if</FONT></B>(dp[idx-1][k-1]+tot&lt;dp[idx][jmid])
			dp[idx][jmid]=dp[idx-1][k-1]+tot,bestk=k;
	}
	computeDP(idx,jleft,jmid-1,kleft,bestk);
	computeDP(idx,jmid+1,jright,bestk,kright);
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
	<B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=0;i&lt;=k;++i)
		<B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> j=0;j&lt;=n;dp[i][j++]=1e17);
	dp[0][0]=0;
	<B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i=1;i&lt;=k;++i)
		computeDP(i,1,n,1,n);
	cout&lt;&lt;dp[k][n];
}</PRE>
<HR>
<A NAME="file28">
<H1>code/LongestIncreasingSubsequence.cc 28/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file27">prev</A>][<A HREF="#file29">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Given a list of numbers of length n, this routine extracts a
</FONT></I><I><FONT COLOR="#B22222">// longest increasing subsequence.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Running time: O(n log n)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   INPUT: a vector of integers
</FONT></I><I><FONT COLOR="#B22222">//   OUTPUT: a vector containing the longest increasing subsequence
</FONT></I>
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt; PII;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;PII&gt; VPII;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">STRICTLY_INCREASNG</FONT>

VI <B><FONT COLOR="#0000FF">LongestIncreasingSubsequence</FONT></B>(VI v) {
  VPII best;
  VI dad(v.size(), -1);

  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v.size(); i++) {
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">STRICTLY_INCREASNG</FONT>
    PII item = make_pair(v[i], 0);
    <B><FONT COLOR="#5F9EA0">VPII</FONT></B>::iterator it = lower_bound(best.begin(), best.end(), item);
    item.second = i;
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
    PII item = make_pair(v[i], i);
    <B><FONT COLOR="#5F9EA0">VPII</FONT></B>::iterator it = upper_bound(best.begin(), best.end(), item);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    <B><FONT COLOR="#A020F0">if</FONT></B> (it == best.end()) {
      dad[i] = (best.size() == 0 ? -1 : best.back().second);
      best.push_back(item);
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      dad[i] = it == best.begin() ? -1 : prev(it)-&gt;second;
      *it = item;
    }
  }

  VI ret;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = best.back().second; i &gt;= 0; i = dad[i])
    ret.push_back(v[i]);
  reverse(ret.begin(), ret.end());
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}
</PRE>
<HR>
<A NAME="file29">
<H1>code/Dates.cc 29/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file28">prev</A>][<A HREF="#file30">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Months are expressed as integers from 1 to 12, Days are expressed
</FONT></I><I><FONT COLOR="#B22222">// as integers from 1 to 31, and Years are expressed as 4-digit
</FONT></I><I><FONT COLOR="#B22222">// integers.
</FONT></I>string dayOfWeek[] = {<B><FONT COLOR="#BC8F8F">&quot;Mon&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Tue&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Wed&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Thu&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Fri&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Sat&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;Sun&quot;</FONT></B>};

<I><FONT COLOR="#B22222">// converts Gregorian date to integer (Julian day number)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">dateToInt</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> m, <B><FONT COLOR="#228B22">int</FONT></B> d, <B><FONT COLOR="#228B22">int</FONT></B> y){  
  <B><FONT COLOR="#A020F0">return</FONT></B> 
    1461 * (y + 4800 + (m - 14) / 12) / 4 +
    367 * (m - 2 - (m - 14) / 12 * 12) / 12 - 
    3 * ((y + 4900 + (m - 14) / 12) / 100) / 4 + 
    d - 32075;
}

<I><FONT COLOR="#B22222">// converts integer (Julian day number) to Gregorian date: month/day/year
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">intToDate</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> jd, <B><FONT COLOR="#228B22">int</FONT></B> &amp;m, <B><FONT COLOR="#228B22">int</FONT></B> &amp;d, <B><FONT COLOR="#228B22">int</FONT></B> &amp;y){
  <B><FONT COLOR="#228B22">int</FONT></B> x, n, i, j;
  x = jd + 68569;
  n = 4 * x / 146097;
  x -= (146097 * n + 3) / 4;
  i = (4000 * (x + 1)) / 1461001;
  x -= 1461 * i / 4 - 31;
  j = 80 * x / 2447;
  d = x - 2447 * j / 80;
  x = j / 11;
  m = j + 2 - 12 * x;
  y = 100 * (n - 49) + i + x;
}

<I><FONT COLOR="#B22222">// converts integer (Julian day number) to day of week
</FONT></I>string <B><FONT COLOR="#0000FF">intToDay</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> jd){
  <B><FONT COLOR="#A020F0">return</FONT></B> dayOfWeek[jd % 7];
}</PRE>
<HR>
<A NAME="file30">
<H1>code/KMP.cc 30/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file29">prev</A>][<A HREF="#file31">next</A>]
<PRE>
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; VI;

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">buildPi</FONT></B>(string&amp; p, VI&amp; pi){
  pi = VI(p.length());
  <B><FONT COLOR="#228B22">int</FONT></B> k = -2;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; p.length(); i++) {
    <B><FONT COLOR="#A020F0">while</FONT></B>(k &gt;= -1 &amp;&amp; p[k+1] != p[i])
      k = (k == -1) ? -2 : pi[k];
    pi[i] = ++k;
  }
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">KMP</FONT></B>(string&amp; t, string&amp; p){
  VI pi;
  buildPi(p, pi);
  <B><FONT COLOR="#228B22">int</FONT></B> k = -1;
  <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; t.length(); i++) {
    <B><FONT COLOR="#A020F0">while</FONT></B>(k &gt;= -1 &amp;&amp; p[k+1] != t[i])
      k = (k == -1) ? -2 : pi[k];
    k++;
    <B><FONT COLOR="#A020F0">if</FONT></B>(k == p.length() - 1) {
      <I><FONT COLOR="#B22222">// p matches t[i-m+1, ..., i]
</FONT></I>      cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;matched at index &quot;</FONT></B> &lt;&lt; i-k &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B>;
      cout &lt;&lt; t.substr(i-k, p.length()) &lt;&lt; endl;
      k = (k == -1) ? -2 : pi[k];
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>(){
  string a = <B><FONT COLOR="#BC8F8F">&quot;AABAACAADAABAABA&quot;</FONT></B>, b = <B><FONT COLOR="#BC8F8F">&quot;AABA&quot;</FONT></B>;
  KMP(a, b); <I><FONT COLOR="#B22222">// expected matches at: 0, 9, 12
</FONT></I>}
</PRE>
<HR>
<A NAME="file31">
<H1>code/2SAT.cc 31/31</H1>
[<A HREF="#top">top</A>][<A HREF="#file30">prev</A>][next]
<PRE>
<B><FONT COLOR="#228B22">struct</FONT></B> TwoSat {
  <B><FONT COLOR="#228B22">int</FONT></B> n;
  vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &gt; adj, radj, scc;
  vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; sid, vis, val;
  stack&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; stk;
  <B><FONT COLOR="#228B22">int</FONT></B> scnt;
  <I><FONT COLOR="#B22222">// n: number of variables, including negations
</FONT></I>  TwoSat(<B><FONT COLOR="#228B22">int</FONT></B> n): n(n), adj(n), radj(n), sid(n), vis(n), val(n, -1) {}
  <I><FONT COLOR="#B22222">// adds an implication
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> impl(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y) { adj[x].push_back(y); radj[y].push_back(x); }
  <I><FONT COLOR="#B22222">// adds a disjunction
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> vee(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y) { impl(x^1, y); impl(y^1, x); }
  <I><FONT COLOR="#B22222">// forces variables to be equal
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> eq(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y) { impl(x, y); impl(y, x); impl(x^1, y^1); impl(y^1, x^1); }
  <I><FONT COLOR="#B22222">// forces variable to be true
</FONT></I>  <B><FONT COLOR="#228B22">void</FONT></B> tru(<B><FONT COLOR="#228B22">int</FONT></B> x) { impl(x^1, x); }
  
  <B><FONT COLOR="#228B22">void</FONT></B> dfs1(<B><FONT COLOR="#228B22">int</FONT></B> x) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (vis[x]++) <B><FONT COLOR="#A020F0">return</FONT></B>;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; adj[x].size(); i++)
      dfs1(adj[x][i]);
    stk.push(x);
  }
  <B><FONT COLOR="#228B22">void</FONT></B> dfs2(<B><FONT COLOR="#228B22">int</FONT></B> x) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!vis[x]) <B><FONT COLOR="#A020F0">return</FONT></B>; vis[x] = 0;
    sid[x] = scnt; scc.back().push_back(x);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; radj[x].size(); i++)
      dfs2(radj[x][i]);
  }

  <I><FONT COLOR="#B22222">// returns true if satisfiable, false otherwise
</FONT></I>  <I><FONT COLOR="#B22222">// on completion, val[x] is the assigned value of variable x
</FONT></I>  <I><FONT COLOR="#B22222">// note, val[x] = 0 implies val[x^1] = 1
</FONT></I>  <B><FONT COLOR="#228B22">bool</FONT></B> two_sat() {
    scnt = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; dfs1(i++));
    <B><FONT COLOR="#A020F0">while</FONT></B> (!stk.empty()) {
      <B><FONT COLOR="#228B22">int</FONT></B> v = stk.top(); stk.pop();
      <B><FONT COLOR="#A020F0">if</FONT></B> (vis[v]) {
        scc.push_back(vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;());
        dfs2(v);
        scnt++;
      }
    }
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i += 2)
      <B><FONT COLOR="#A020F0">if</FONT></B> (sid[i] == sid[i+1]) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; must(scnt);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; scnt; i++)
      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; scc[i].size(); j++){
        val[scc[i][j]] = must[i];
        must[sid[scc[i][j]^1]] = !must[i];
      }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
  }
};</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.6</A>.</ADDRESS>
</BODY>
</HTML>
